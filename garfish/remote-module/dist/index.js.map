{
  "version": 3,
  "sources": ["../src/index.ts", "../src/hooks.ts", "../src/common.ts", "../src/apis/loadModule.ts", "../src/actuator.ts", "../src/apis/setModuleConfig.ts", "../src/apis/preload.ts", "../src/apis/esModule.ts", "../src/apis/loadModuleSync.ts"],
  "sourcesContent": ["import { hooks } from './hooks';\nimport { loader, cacheModules } from './common';\nimport { preload } from './apis/preload';\nimport { esModule } from './apis/esModule';\nimport { loadModule } from './apis/loadModule';\nimport { loadModuleSync } from './apis/loadModuleSync';\nimport { setModuleConfig } from './apis/setModuleConfig';\n\n// Remote module loader uses singleton mode\nconst Apis = {\n  preload,\n  esModule,\n  loadModule,\n  loadModuleSync,\n  setModuleConfig,\n  hooks,\n  loader,\n  cacheModules,\n};\n\nexport {\n  preload,\n  esModule,\n  loadModule,\n  loadModuleSync,\n  setModuleConfig,\n  hooks,\n  loader,\n  cacheModules,\n  Apis as default,\n};\n", "import type { ModuleManager } from '@garfish/loader';\nimport {\n  PluginSystem,\n  SyncHook,\n  SyncWaterfallHook,\n  AsyncWaterfallHook,\n} from '@garfish/hooks';\nimport type { Actuator } from './actuator';\nimport type { ModuleConfig, ModuleInfo } from './common';\n\nexport interface BeforeLoadArgs {\n  url: string;\n  options?: ModuleConfig;\n}\n\nexport interface afterLoadArgs {\n  url: string;\n  code: string;\n  exports: Record<string, any>;\n}\n\nexport const hooks = new PluginSystem({\n  preloaded: new SyncHook<[ModuleManager], any>(),\n  initModule: new SyncHook<[Actuator], any>('initModule'),\n  beforeLoadModule: new SyncWaterfallHook<BeforeLoadArgs>('beforeLoadModule'),\n  asyncBeforeLoadModule: new AsyncWaterfallHook<BeforeLoadArgs>(\n    'asyncBeforeLoadModule',\n  ),\n  afterLoadModule: new SyncWaterfallHook<afterLoadArgs>('afterLoadModule'),\n  asyncAfterLoadModule: new AsyncWaterfallHook<afterLoadArgs>(\n    'asyncAfterLoadModule',\n  ),\n});\n", "import { Loader, ModuleManager } from '@garfish/loader';\nimport {\n  isObject,\n  isPlainObject,\n  deepMerge,\n  safeWrapper,\n  __LOADER_FLAG__,\n} from '@garfish/utils';\nimport { loadModule } from './apis/loadModule';\n\ntype PartialPart<T, K extends keyof T> = {\n  [P in Exclude<keyof T, K>]-?: T[P];\n} & {\n  [P in K]?: T[P];\n};\n\nexport type ModuleConfig = PartialPart<\n  Required<Omit<ModuleInfo, 'version'> & { alias: Record<string, string> }>,\n  'externals'\n>;\n\nexport interface ModuleInfo {\n  cache: boolean;\n  version: string;\n  externals: Record<string, any>;\n  error: null | ((err: Error, info: ModuleInfo, alias: string) => any);\n  adapter: null | ((cjsModule: Record<string, any>) => Record<string, any>);\n}\n\nexport let currentApp: any;\nexport let resourcesStore: Array<ModuleManager> = [];\nexport const cacheModules = Object.create(null);\nexport const fetchLoading = Object.create(null);\nexport const moduleConfig: ModuleConfig = {\n  alias: {},\n  cache: true, // Default use cache\n  error: null,\n  adapter: null,\n  externals: {\n    loadModule, // Only `loadModule` is provided for use by remote modules\n  },\n};\n\n// If garfish has pre-prepared data\nlet garfishGlobalEnv;\n\nsafeWrapper(() => {\n  // @ts-ignore\n  garfishGlobalEnv = __GARFISH_GLOBAL_ENV__;\n\n  // Inherit the configuration from garfish\n  if (isObject(garfishGlobalEnv)) {\n    const { externals, currentApp: app, remoteModulesCode } = garfishGlobalEnv;\n    if (app) {\n      currentApp = app;\n    }\n    if (isObject(externals)) {\n      Object.assign(moduleConfig.externals, externals);\n    }\n    if (Array.isArray(remoteModulesCode)) {\n      resourcesStore = resourcesStore.concat(remoteModulesCode);\n      remoteModulesCode.forEach((manager) => {\n        if (manager.alias) {\n          moduleConfig.alias[manager.alias] = manager.url;\n        }\n      });\n    }\n  }\n});\n\nexport const loader: Loader = (() => {\n  if (isObject(garfishGlobalEnv)) {\n    const loader = garfishGlobalEnv.loader;\n    // Garfish loader will have an identifier\n    if (isObject(loader) && loader.personalId === __LOADER_FLAG__) {\n      return loader;\n    }\n  }\n  return new Loader();\n})();\n\nexport const getModuleManager = (url: string) => {\n  if (url) {\n    // Do not use redirected url\n    return resourcesStore.find((manager) => manager.originUrl === url);\n  }\n};\n\nexport const purifyOptions = (urlOrAlias: string, options?: ModuleConfig) => {\n  let config;\n  const globalExternals = moduleConfig.externals;\n  delete moduleConfig.externals;\n\n  if (isPlainObject(options)) {\n    const curExternals = options.externals;\n    delete options.externals;\n    config = deepMerge(moduleConfig, { ...options, url: urlOrAlias });\n    options.externals = curExternals;\n    config.externals = { ...globalExternals, ...curExternals };\n  } else {\n    config = deepMerge(moduleConfig, { url: urlOrAlias });\n    config.externals = globalExternals;\n  }\n\n  moduleConfig.externals = globalExternals;\n\n  return config as ModuleInfo & {\n    url: string;\n  };\n};\n\nexport const prettifyError = (\n  error: Error | string,\n  alias: string,\n  url: string,\n) => {\n  const tipMarkers = [currentApp && currentApp.name, alias, url];\n  let prefix = tipMarkers.reduce((msg, val, i) => {\n    if (!val) return msg;\n    return i === tipMarkers.length - 1\n      ? msg + `\"${val}\"`\n      : msg + `\"${val}\" -> `;\n  }, 'remoteModule: ');\n  prefix = ` (${prefix})`;\n\n  if (typeof error === 'number') {\n    error = String(error);\n  }\n  if (typeof error === 'string') {\n    if (!error.endsWith(prefix)) {\n      return `${error}${prefix}`;\n    }\n  }\n  if (error instanceof Error) {\n    if (!error.message.endsWith(prefix)) {\n      error.message = `${error.message}${prefix}`;\n    }\n  }\n  return error;\n};\n", "import { assert, isPromise, isAbsolute } from '@garfish/utils';\nimport {\n  loader,\n  ModuleInfo,\n  cacheModules,\n  fetchLoading,\n  purifyOptions,\n  prettifyError,\n  ModuleConfig,\n} from '../common';\nimport { hooks } from '../hooks';\nimport { Actuator } from '../actuator';\nimport { processAlias, getValueInObject } from './setModuleConfig';\n\nexport async function loadModule(\n  urlOrAlias: string,\n  options?: ModuleConfig,\n): Promise<Record<string, any> | null> {\n  const data = await hooks.lifecycle.asyncBeforeLoadModule.emit({\n    options,\n    url: urlOrAlias,\n  });\n  if (data === false) {\n    return null;\n  }\n\n  urlOrAlias = data.url;\n  options = data.options;\n\n  assert(urlOrAlias, 'Missing url for loading remote module.');\n  assert(\n    typeof urlOrAlias === 'string',\n    'The type of URL needs to be a string.',\n  );\n  const [url, segments] = processAlias(urlOrAlias);\n  assert(\n    isAbsolute(url) || url.startsWith('//'),\n    `The loading of the remote module must be an absolute path. \"${url}\"`,\n  );\n\n  const info = purifyOptions(url, options);\n  const { cache, version, externals, error, adapter } = info;\n  const urlWithVersion = `${version || 'latest'}@${url}`; // `latest@https://xx.js`\n\n  const asyncLoadProcess = async () => {\n    let result: Record<string, any> | null = null;\n    let module = cacheModules[urlWithVersion];\n\n    if (cache && module) {\n      if (isPromise(module)) {\n        module = await module;\n      }\n      result = getValueInObject(module, segments);\n    } else {\n      try {\n        const data = await loader.loadModule(url);\n        if (data.resourceManager) {\n          const actuator = new Actuator(data.resourceManager, externals);\n          cacheModules[urlWithVersion] = actuator.env.exports;\n          let exports = actuator.execScript().exports;\n\n          if (typeof adapter === 'function') {\n            exports = adapter(exports);\n          }\n          const hookResult = await hooks.lifecycle.asyncAfterLoadModule.emit({\n            url,\n            exports,\n            code: data.resourceManager.moduleCode,\n          });\n          if (hookResult === false) {\n            return null;\n          }\n          exports = hookResult.exports;\n\n          cacheModules[urlWithVersion] = exports;\n          if (isPromise(exports)) {\n            exports = await exports;\n          }\n          result = getValueInObject(exports, segments);\n        }\n      } catch (e) {\n        delete cacheModules[urlWithVersion];\n        const alias = segments ? segments[0] : '';\n        if (typeof error === 'function') {\n          result = error(e, info, alias);\n        } else {\n          throw prettifyError(e, alias, url);\n        }\n      }\n    }\n    return result;\n  };\n\n  if (fetchLoading[urlWithVersion]) {\n    return fetchLoading[urlWithVersion].then(() => {\n      // The modules are the same, but the aliases may be different\n      return Promise.resolve(cacheModules[urlWithVersion]).then((m) =>\n        getValueInObject(m, segments),\n      );\n    });\n  } else {\n    fetchLoading[urlWithVersion] = asyncLoadProcess().then((data) => {\n      fetchLoading[urlWithVersion] = null;\n      return data;\n    });\n    return fetchLoading[urlWithVersion];\n  }\n}\n", "import { evalWithEnv } from '@garfish/utils';\nimport { ModuleManager } from '@garfish/loader';\nimport { hooks } from './hooks';\nimport { currentApp, moduleConfig } from './common';\n\nexport class Actuator {\n  private manager: ModuleManager;\n  public env: Record<string, any>;\n\n  constructor(manager: ModuleManager, externals?: Record<string, any>) {\n    this.manager = manager;\n    this.env = {\n      exports: {},\n      module: null,\n      require: (key) =>\n        (externals || {})[key] ||\n        (moduleConfig.externals && moduleConfig.externals[key]) ||\n        currentApp?.context?.externals[key],\n    };\n    this.env.module = this.env;\n    hooks.lifecycle.initModule.emit(this);\n  }\n\n  execScript() {\n    const { url, moduleCode } = this.manager;\n    if (currentApp) {\n      // Avoid conflict with Garfish cjs\n      currentApp.execScript(moduleCode, this.env, url, { noEntry: true });\n    } else {\n      const sourceUrl = `\\n${url ? `//# sourceURL=${url}\\n` : ''}`;\n      evalWithEnv(`;${moduleCode}\\n${sourceUrl}`, this.env, window);\n    }\n    return this.env;\n  }\n}\n", "import {\n  warn,\n  hasOwn,\n  assert,\n  isObject,\n  isAbsolute,\n  isPlainObject,\n} from '@garfish/utils';\nimport { moduleConfig, ModuleConfig } from '../common';\n\n// setModuleInfo({ alias: { utils: 'https://xx.js' } });\n// loadModule('@utils').then((utils) => {});\nconst MARKER = '@';\n\nconst setAlias = (obj: ModuleConfig['alias']) => {\n  for (const key in obj) {\n    const value = obj[key];\n    assert(\n      isAbsolute(value),\n      `The loading of the remote module must be an absolute path. \"${value}\"`,\n    );\n    moduleConfig.alias[key] = value;\n  }\n};\n\nexport function setModuleConfig(obj: Partial<ModuleConfig>) {\n  assert(isPlainObject(obj), 'Module configuration must be an object.');\n  for (const key in obj) {\n    if (hasOwn(moduleConfig, key)) {\n      if (key === 'env') {\n        Object.assign(moduleConfig[key], obj[key]);\n      } else if (key === 'alias') {\n        const val = obj[key];\n        val && setAlias(val);\n      } else {\n        moduleConfig[key] = obj[key];\n      }\n    } else if ((typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false)) {\n      warn(`Invalid configuration \"${key}\".`);\n    }\n  }\n}\n\nexport function processAlias(url: string): [string, Array<string> | undefined] {\n  // If url is an alias\n  if (url && url.startsWith(MARKER)) {\n    const segments = url.slice(MARKER.length).split('.');\n    const name = segments[0];\n    const realUrl = moduleConfig.alias[name];\n    assert(realUrl, `Alias \"${name}\" is not defined.`);\n    return [realUrl, segments];\n  }\n  return [url, undefined];\n}\n\nexport function getValueInObject(\n  obj: Record<string, any>,\n  segments?: Array<string>,\n) {\n  if (Array.isArray(segments)) {\n    const l = segments.length;\n    if (l > 1) {\n      for (let i = 1; i < l; i++) {\n        const p = segments[i];\n        // prettier-ignore\n        assert(\n          isObject(obj),\n          `Remote module \"${segments.slice(0, i).join('.')}\" is ${obj}, cannot get \"${p}\" attribute from it.`,\n        );\n        obj = obj[p];\n      }\n    }\n  }\n  return obj;\n}\n", "import { assert, isAbsolute } from '@garfish/utils';\nimport { hooks } from '../hooks';\nimport { processAlias } from './setModuleConfig';\nimport { loader, resourcesStore } from '../common';\n\n// Preload the static resources of the module, so that the module can be loaded synchronously\nexport function preload(urls: string | Array<string>) {\n  if (!Array.isArray(urls)) urls = [urls];\n\n  return Promise.all(\n    urls.map((url) => {\n      url = processAlias(url)[0];\n      assert(\n        isAbsolute(url),\n        `The loading of the remote module must be an absolute path. \"${url}\"`,\n      );\n      return loader.loadModule(url).then((data) => {\n        if (data.resourceManager) {\n          data.resourceManager.originUrl = url;\n          resourcesStore.push(data.resourceManager);\n          hooks.lifecycle.preloaded.emit(data.resourceManager);\n        }\n        return data;\n      });\n    }),\n  );\n}\n", "import { isObject, isPromise } from '@garfish/utils';\n\ntype ESModuleResult<T> = {\n  default: T;\n  __esModule: true;\n};\n\n// prettier-ignore\nexport function esModule<T extends Promise<any>>(obj: T): Promise<ESModuleResult<T extends Promise<infer P> ? P : T>>;\nexport function esModule<T extends ESModuleResult<any>>(obj: T): T;\nexport function esModule<T>(obj: T): ESModuleResult<T>;\n\nexport function esModule(obj: any) {\n  if (isObject(obj) && obj.__esModule === true) {\n    return obj;\n  } else if (isPromise(obj)) {\n    return obj.then(esModule);\n  } else {\n    const esm = { default: obj };\n    Object.defineProperty(esm, '__esModule', { value: true });\n    return esm;\n  }\n}\n", "import { error, assert, isPromise, isAbsolute } from '@garfish/utils';\nimport {\n  ModuleInfo,\n  cacheModules,\n  purifyOptions,\n  prettifyError,\n  getModuleManager,\n  ModuleConfig,\n} from '../common';\nimport { hooks } from '../hooks';\nimport { Actuator } from '../actuator';\nimport { processAlias, getValueInObject } from './setModuleConfig';\n\n// If we want to have perfect synchronization syntax to load remote modules,\n// the source code of the child application must be analyzed so that it can be loaded on demand.\n// In the future, we need to wait until garfish supports esModule,\n// To consider loading remote modules on demand when using synchronous syntax.\n// E.g.\n// 1. esModule - Static analysis, recursively build dependency tree.\n// 2. webpack - Analyze the source code ast and build into different package versions.\n\nconst throwWarn = (alias: string, url: string) => {\n  error(\n    prettifyError(\n      `The current module return a promise, You should use \"loadModule('${url}')\".`,\n      alias,\n      url,\n    ),\n  );\n};\n\nexport function loadModuleSync(\n  urlOrAlias: string,\n  options?: ModuleConfig,\n): Record<string, any> | null {\n  const data = hooks.lifecycle.beforeLoadModule.emit({\n    options,\n    url: urlOrAlias,\n  });\n  urlOrAlias = data.url;\n  options = data.options;\n\n  assert(urlOrAlias, 'Missing url for loading remote module.');\n  assert(\n    typeof urlOrAlias === 'string',\n    'The type of URL needs to be a string.',\n  );\n  const [url, segments] = processAlias(urlOrAlias);\n  assert(\n    isAbsolute(url) || url.startsWith('//'),\n    `The loading of the remote module must be an absolute path. \"${url}\"`,\n  );\n\n  let result: Record<string, any> | null = null;\n  const info = purifyOptions(url, options);\n  const { cache, version, externals, error, adapter } = info;\n  const urlWithVersion = `${version || 'latest'}@${url}`;\n  const module = cacheModules[urlWithVersion];\n  const alias = segments ? segments[0] : '';\n\n  if (cache && module) {\n    isPromise(module) && throwWarn(alias, url);\n    result = getValueInObject(module, segments);\n  } else {\n    const manager = getModuleManager(url);\n    assert(\n      manager,\n      `Synchronously load module must load resources in advance. \"${url}\"`,\n    );\n\n    try {\n      const actuator = new Actuator(manager, externals);\n      cacheModules[urlWithVersion] = actuator.env.exports;\n      let exports = actuator.execScript().exports;\n\n      if (typeof adapter === 'function') {\n        exports = adapter(exports);\n      }\n      exports = hooks.lifecycle.afterLoadModule.emit({\n        url,\n        exports,\n        code: manager.moduleCode,\n      }).exports;\n\n      isPromise(exports) && throwWarn(alias, url);\n      cacheModules[urlWithVersion] = exports;\n      result = getValueInObject(exports, segments);\n    } catch (e) {\n      delete cacheModules[urlWithVersion];\n      if (typeof error === 'function') {\n        result = error(e, info, alias);\n      } else {\n        throw prettifyError(e, alias, url);\n      }\n    }\n  }\n  return result;\n}\n"],
  "mappings": "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",
  "names": []
}
