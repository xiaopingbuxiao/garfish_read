{
  "version": 3,
  "sources": ["../../src/runtime.ts", "../../src/compiler/index.ts", "../../src/compiler/types.ts", "../../src/compiler/generated.ts", "../../src/compiler/mergeMap.ts", "../../src/compiler/state.ts", "../../src/compiler/scope.ts", "../../src/compiler/collectorVisitor.ts", "../../src/module.ts", "../../src/pluginify.ts"],
  "sourcesContent": ["import {\n  toBase64,\n  deepMerge,\n  isPromise,\n  isPlainObject,\n  evalWithEnv,\n  transformUrl,\n  warn,\n  assert,\n} from '@garfish/utils';\nimport { Loader, LoaderOptions, JavaScriptManager } from '@garfish/loader';\nimport { Output, Compiler } from './compiler';\nimport { Module, MemoryModule, createModule, createImportMeta } from './module';\n\nexport type ModuleResource = Output & {\n  storeId: string;\n  realUrl: string;\n  exports: Array<string>;\n};\n\nexport interface RuntimeOptions {\n  scope: string;\n  loaderOptions?: LoaderOptions;\n  execCode?: (\n    output: ModuleResource,\n    provider: ReturnType<Runtime['generateProvider']>,\n  ) => void;\n}\n\nexport class Runtime {\n  private modules = new WeakMap<MemoryModule, Module>();\n  private memoryModules: Record<string, MemoryModule> = {};\n  public loader: Loader;\n  public options: RuntimeOptions;\n  public resources: Record<string, ModuleResource | Promise<void>> = {};\n\n  constructor(options?: RuntimeOptions) {\n    const defaultOptions = {\n      scope: 'default',\n      loaderOptions: {},\n    };\n    this.options = isPlainObject(options)\n      ? deepMerge(defaultOptions, options)\n      : defaultOptions;\n    this.loader = new Loader(this.options.loaderOptions);\n  }\n\n  private execCode(output: ModuleResource, memoryModule: MemoryModule) {\n    const provider = this.generateProvider(output, memoryModule);\n\n    if (this.options.execCode) {\n      this.options.execCode(output, provider);\n    } else {\n      const sourcemap = `\\n//@ sourceMappingURL=${output.map}`;\n      const code = `${output.code}\\n//${output.storeId}${sourcemap}`;\n      evalWithEnv(code, provider, undefined, true);\n    }\n  }\n\n  private importModule(\n    storeId: string,\n    requestUrl?: string,\n  ): MemoryModule | Promise<MemoryModule> {\n    let memoryModule = this.memoryModules[storeId];\n    if (!memoryModule) {\n      const get = () => {\n        const output = this.resources[storeId] as ModuleResource;\n        if (!output) {\n          throw new Error(`Module '${storeId}' not found`);\n        }\n        memoryModule = this.memoryModules[storeId] = {};\n        this.execCode(output, memoryModule);\n        return memoryModule;\n      };\n      if (requestUrl) {\n        const res = this.compileAndFetchCode(storeId, requestUrl);\n        if (isPromise(res)) return res.then(() => get());\n      }\n      return get();\n    }\n    return memoryModule;\n  }\n\n  private getModule(memoryModule: MemoryModule) {\n    if (!this.modules.has(memoryModule)) {\n      this.modules.set(memoryModule, createModule(memoryModule));\n    }\n    return this.modules.get(memoryModule);\n  }\n\n  private generateProvider(output: ModuleResource, memoryModule: MemoryModule) {\n    return {\n      [Compiler.keys.__GARFISH_IMPORT_META__]: createImportMeta(output.realUrl),\n\n      [Compiler.keys.__GARFISH_NAMESPACE__]: (memoryModule: MemoryModule) => {\n        return this.getModule(memoryModule);\n      },\n\n      [Compiler.keys.__GARFISH_IMPORT__]: (moduleId: string) => {\n        const storeId = transformUrl(output.storeId, moduleId);\n        return this.import(storeId);\n      },\n\n      [Compiler.keys.__GARFISH_DYNAMIC_IMPORT__]: (moduleId: string) => {\n        const storeId = transformUrl(output.storeId, moduleId);\n        const requestUrl = transformUrl(output.realUrl, moduleId);\n        return this.importByUrl(storeId, requestUrl);\n      },\n\n      [Compiler.keys.__GARFISH_EXPORT__]: (\n        exportObject: Record<string, () => any>,\n      ) => {\n        Object.keys(exportObject).forEach((key) => {\n          Object.defineProperty(memoryModule, key, {\n            enumerable: true,\n            get: exportObject[key],\n            set: () => {\n              throw new TypeError('Assignment to constant variable.');\n            },\n          });\n        });\n      },\n    };\n  }\n\n  private async analysisModule(\n    code: string,\n    storeId: string,\n    baseRealUrl: string,\n  ) {\n    const compiler = new Compiler({\n      code,\n      storeId,\n      runtime: this,\n      filename: storeId,\n    });\n    const { imports, exports, generateCode } = compiler.transform();\n\n    await Promise.all(\n      imports.map(({ moduleId }) => {\n        const curStoreId = transformUrl(storeId, moduleId);\n        const requestUrl = transformUrl(baseRealUrl, moduleId);\n        return this.resources[curStoreId]\n          ? null\n          : this.compileAndFetchCode(curStoreId, requestUrl);\n      }),\n    );\n\n    const output = await generateCode();\n    output.map = await toBase64(output.map);\n    (output as ModuleResource).storeId = storeId;\n    (output as ModuleResource).realUrl = baseRealUrl;\n    (output as ModuleResource).exports = exports;\n    return output as ModuleResource;\n  }\n\n  private compileAndFetchCode(\n    storeId: string,\n    url?: string,\n  ): void | Promise<void> {\n    if (this.resources[storeId]) return;\n    if (!url) url = storeId;\n\n    const p = this.loader\n      .load<JavaScriptManager>({ scope: this.options.scope, url })\n      .then(async ({ resourceManager }) => {\n        if (resourceManager) {\n          const { url, scriptCode } = resourceManager;\n\n          if (scriptCode) {\n            assert(url, 'url is required');\n            const output = await this.analysisModule(scriptCode, storeId, url);\n            this.resources[storeId] = output;\n          } else {\n            delete this.resources[storeId];\n          }\n        } else {\n          warn(`Module '${storeId}' not found`);\n        }\n      });\n    this.resources[storeId] = p;\n    return p;\n  }\n\n  import(storeId: string) {\n    return this.importModule(storeId) as MemoryModule;\n  }\n\n  importByUrl(storeId: string, requestUrl?: string) {\n    const result = this.importModule(storeId, requestUrl || storeId);\n    return Promise.resolve(result).then((memoryModule) => {\n      return this.getModule(memoryModule);\n    });\n  }\n\n  async importByCode(code: string, storeId: string, metaUrl?: string) {\n    if (!metaUrl) metaUrl = storeId;\n    const memoryModule = {};\n    const output = await this.analysisModule(code, storeId, metaUrl);\n    this.execCode(output as ModuleResource, memoryModule);\n    return this.getModule(memoryModule);\n  }\n}\n", "import { ancestor } from 'acorn-walk';\nimport { generate } from 'escodegen';\nimport { Parser, Node as AcornNode } from 'acorn';\nimport { transformUrl, haveSourcemap } from '@garfish/utils';\nimport type {\n  Node,\n  Program,\n  Identifier,\n  Expression,\n  MetaProperty,\n  CallExpression,\n  MemberExpression,\n  VariableDeclaration,\n  ExportDefaultDeclaration,\n  ImportSpecifier,\n  ImportExpression,\n  ImportDeclaration,\n  ExportAllDeclaration,\n  ExportNamedDeclaration,\n} from 'estree';\nimport {\n  isIdentifier,\n  isVariableDeclaration,\n  isExportSpecifier,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n} from './types';\nimport {\n  literal,\n  identifier,\n  callExpression,\n  objectProperty,\n  objectExpression,\n  memberExpression,\n  arrowFunctionExpression,\n  variableDeclarator,\n  variableDeclaration,\n} from './generated';\nimport type { Scope } from './scope';\nimport { mergeSourcemap } from './mergeMap';\nimport { State, createState } from './state';\nimport { Runtime, ModuleResource } from '../runtime';\n\ntype ImportInfoData = (\n  | ReturnType<Compiler['getImportInformation']>\n  | ReturnType<Compiler['getImportInformationBySource']>\n) & {\n  moduleName: string;\n};\n\ntype ImportTransformNode = ReturnType<Compiler['generateImportTransformNode']>;\n\ninterface CompilerOptions {\n  code: string;\n  storeId: string;\n  filename: string;\n  runtime: Runtime;\n}\n\nexport interface Output {\n  map: string;\n  code: string;\n}\n\nexport class Compiler {\n  static keys = {\n    __GARFISH_IMPORT__: '__GARFISH_IMPORT__',\n    __GARFISH_EXPORT__: '__GARFISH_EXPORT__',\n    __GARFISH_DEFAULT__: '__GARFISH_DEFAULT__',\n    __GARFISH_WRAPPER__: '__GARFISH_WRAPPER__',\n    __GARFISH_NAMESPACE__: '__GARFISH_NAMESPACE__',\n    __GARFISH_IMPORT_META__: '__GARFISH_IMPORT_META__',\n    __GARFISH_DYNAMIC_IMPORT__: '__GARFISH_DYNAMIC_IMPORT__',\n  };\n\n  private ast: Program;\n  private state: ReturnType<typeof createState>;\n\n  private moduleCount = 0;\n  private consumed = false;\n  private importInfos: Array<{\n    data: ImportInfoData;\n    transformNode: ImportTransformNode;\n  }> = [];\n  private exportInfos: Array<{\n    name: string;\n    refNode: Identifier | CallExpression | MemberExpression;\n  }> = [];\n  private deferQueue = {\n    removes: new Set<() => void>(),\n    replaces: new Set<() => void>(),\n    importChecks: new Set<() => void>(),\n    identifierRefs: new Set<() => void>(),\n    exportNamespaces: new Set<{\n      moduleId: string;\n      namespace: string | undefined;\n      fn: (names: Array<string>) => void;\n    }>(),\n  };\n\n  public options: CompilerOptions;\n  public sourcemapComment: string;\n\n  constructor(options: CompilerOptions) {\n    this.options = options;\n    this.ast = this.parse();\n    this.state = createState(this.ast);\n  }\n\n  private parse() {\n    const parser = new Parser(\n      {\n        locations: true,\n        sourceType: 'module',\n        ecmaVersion: 'latest',\n        sourceFile: this.options.filename,\n        onComment: (isBlock, text) => this.onParseComment(isBlock, text),\n      },\n      this.options.code,\n    );\n    try {\n      return parser.parse() as unknown as Program;\n    } catch (e) {\n      e.message += `(${this.options.filename})`;\n      throw e;\n    }\n  }\n\n  private onParseComment(isBlock: boolean, text: string) {\n    if (haveSourcemap(text)) {\n      this.sourcemapComment = text;\n    }\n  }\n\n  private checkImportNames(\n    imports: ImportInfoData['imports'],\n    moduleId: string,\n  ) {\n    const exports = this.getChildModuleExports(moduleId);\n    if (exports) {\n      imports.forEach((item) => {\n        if (item.isNamespace) return;\n        const checkName = item.isDefault ? 'default' : item.name;\n        if (!exports.includes(checkName)) {\n          throw SyntaxError(\n            `(${this.options.filename}): The module '${moduleId}' does not provide an export named '${checkName}'`,\n          );\n        }\n      });\n    }\n  }\n\n  private getChildModuleExports(moduleId: string) {\n    const storeId = transformUrl(this.options.storeId, moduleId);\n    const output = this.options.runtime.resources[storeId] as ModuleResource;\n    return output ? output.exports : null;\n  }\n\n  private getImportInformation(node: ImportDeclaration) {\n    const imports = node.specifiers.map((n) => {\n      const isDefault = isImportDefaultSpecifier(n);\n      const isNamespace = isImportNamespaceSpecifier(n);\n      const isSpecial = isDefault || isNamespace;\n      const alias = isSpecial ? null : n.local.name;\n      const name = isSpecial\n        ? n.local.name\n        : (n as ImportSpecifier).imported.name;\n      return {\n        name,\n        isDefault,\n        isNamespace,\n        alias: alias === name ? null : alias,\n      };\n    });\n\n    return {\n      imports,\n      isExport: false,\n      moduleId: node.source.value as string,\n    };\n  }\n\n  private getImportInformationBySource(\n    node: ExportNamedDeclaration | ExportAllDeclaration,\n  ) {\n    const imports = ((node as ExportNamedDeclaration).specifiers || []).map(\n      (n) => {\n        const alias = n.exported.name;\n        const name = n.local.name;\n        return {\n          name,\n          alias: alias === name ? null : alias,\n        };\n      },\n    );\n\n    return {\n      imports,\n      isExport: true,\n      moduleId: node.source?.value as string,\n    };\n  }\n\n  private generateImportTransformNode(moduleName: string, moduleId: string) {\n    const varName = identifier(moduleName);\n    const varExpr = callExpression(\n      identifier(Compiler.keys.__GARFISH_IMPORT__),\n      [literal(moduleId)],\n    );\n    const varNode = variableDeclarator(varName, varExpr);\n    return variableDeclaration('const', [varNode]);\n  }\n\n  private generateIdentifierTransformNode(\n    nameOrInfo: string | ReturnType<Compiler['findIndexInData']>,\n  ) {\n    let info;\n    if (typeof nameOrInfo === 'string') {\n      for (const { data } of this.importInfos) {\n        if (!data.isExport) {\n          const result = this.findIndexInData(nameOrInfo, data);\n          if (result) {\n            info = result;\n            break;\n          }\n        }\n      }\n    } else {\n      info = nameOrInfo;\n    }\n\n    if (info && info.data) {\n      const { i, data } = info;\n      const item = data.imports[i];\n      if (item.isNamespace) {\n        return callExpression(identifier(Compiler.keys.__GARFISH_NAMESPACE__), [\n          identifier(data.moduleName),\n        ]);\n      } else {\n        const propName = item.isDefault ? 'default' : item.name;\n        return memberExpression(\n          identifier(data.moduleName),\n          identifier(propName),\n        );\n      }\n    }\n  }\n\n  private generateVirtualModuleSystem() {\n    const exportNodes = this.exportInfos.map(({ name, refNode }) => {\n      return objectProperty(\n        identifier(name),\n        arrowFunctionExpression([], refNode),\n      );\n    });\n    const exportCallExpression = callExpression(\n      identifier(Compiler.keys.__GARFISH_EXPORT__),\n      [objectExpression(exportNodes)],\n    );\n    this.ast.body.unshift(\n      exportCallExpression as any,\n      ...new Set(this.importInfos.map((val) => val.transformNode)),\n    );\n  }\n\n  private findIndexInData(refName: string, data: ImportInfoData) {\n    for (let i = 0; i < data.imports.length; i++) {\n      const { name, alias } = data.imports[i];\n      if (refName === alias || refName === name) {\n        return { i, data };\n      }\n    }\n  }\n\n  private findImportInfo(moduleId: string): [string?, VariableDeclaration?] {\n    for (const { data, transformNode } of this.importInfos) {\n      if (data.moduleId === moduleId) {\n        return [data.moduleName, transformNode];\n      }\n    }\n    return [];\n  }\n\n  private isReferencedModuleVariable(scope: Scope, node: Identifier) {\n    const u = () =>\n      Object.keys(scope.bindings).some((key) => {\n        const { kind, references, constantViolations } = scope.bindings[key];\n        if (kind === 'module') {\n          return references.has(node) || constantViolations.has(node);\n        }\n      });\n    while (scope) {\n      if (u()) return true;\n      if (scope.parent) {\n        scope = scope.parent;\n      } else {\n        break;\n      }\n    }\n    return false;\n  }\n\n  // 1. export { a as default };\n  // 2. export { default as x } from 'module';\n  private processExportSpecifiers(\n    node: ExportNamedDeclaration,\n    state: State,\n    ancestors: Array<Node>,\n  ) {\n    if (node.source) {\n      const moduleId = node.source.value as string;\n      const data = this.getImportInformationBySource(node);\n      let [moduleName, transformNode] = this.findImportInfo(moduleId);\n\n      if (!moduleName) {\n        moduleName = `__m${this.moduleCount++}__`;\n        transformNode = this.generateImportTransformNode(moduleName, moduleId);\n      }\n\n      (data as ImportInfoData).moduleName = moduleName;\n      transformNode &&\n        this.importInfos.push({ data: data as ImportInfoData, transformNode });\n      this.deferQueue.importChecks.add(() =>\n        this.checkImportNames(data.imports, moduleId),\n      );\n\n      node.specifiers.forEach((n) => {\n        const useInfo = this.findIndexInData(\n          n.local.name,\n          data as ImportInfoData,\n        );\n        const refNode = this.generateIdentifierTransformNode(useInfo);\n        refNode && this.exportInfos.push({ refNode, name: n.exported.name });\n      });\n    } else {\n      const scope = state.getScopeByAncestors(ancestors);\n      node.specifiers.forEach((n) => {\n        const refNode =\n          scope && this.isReferencedModuleVariable(scope, n.local)\n            ? this.generateIdentifierTransformNode(n.local.name)\n            : identifier(n.local.name);\n        refNode && this.exportInfos.push({ refNode, name: n.exported.name });\n      });\n    }\n    this.deferQueue.removes.add(() => state.remove(ancestors));\n  }\n\n  // 1. export default 1;\n  // 2. export const a = 1;\n  private processExportNamedDeclaration(\n    node: ExportNamedDeclaration | ExportDefaultDeclaration,\n    state: State,\n    ancestors: Array<Node>,\n  ) {\n    const isDefault = isExportDefaultDeclaration(node);\n    if (node.declaration) {\n      const nodes = isVariableDeclaration(node.declaration)\n        ? node.declaration.declarations\n        : [node.declaration];\n\n      nodes.forEach((node) => {\n        if (isDefault) {\n          const name = 'default';\n          const refNode = identifier(Compiler.keys.__GARFISH_DEFAULT__);\n          this.exportInfos.push({ name, refNode });\n        } else {\n          const names = state.getBindingIdentifiers(node.id);\n          names.forEach(({ name }) => {\n            this.exportInfos.push({ name, refNode: identifier(name) });\n          });\n        }\n      });\n\n      if (isDefault) {\n        this.deferQueue.replaces.add(() => {\n          // \u6B64\u65F6 declaration \u53EF\u80FD\u5DF2\u7ECF\u88AB\u66FF\u6362\u8FC7\u4E86\n          const varName = identifier(Compiler.keys.__GARFISH_DEFAULT__);\n          const varNode = variableDeclarator(\n            varName,\n            node.declaration as Expression,\n          );\n          state.replaceWith(variableDeclaration('const', [varNode]), ancestors);\n        });\n      } else if (node.declaration && isIdentifier(node.declaration)) {\n        this.deferQueue.removes.add(() => state.remove(ancestors));\n      } else {\n        node.declaration &&\n          this.deferQueue.replaces.add(() => {\n            node.declaration && state.replaceWith(node.declaration, ancestors);\n          });\n      }\n    }\n  }\n\n  // 1. export * from 'module';\n  // 2. export * as x from 'module';\n  private processExportAllDeclaration(\n    node: ExportAllDeclaration,\n    state: State,\n    ancestors: Array<Node>,\n  ) {\n    const namespace = node.exported?.name;\n    const moduleId = node.source.value as string;\n    const data = this.getImportInformationBySource(node);\n    let [moduleName, transformNode] = this.findImportInfo(moduleId);\n\n    if (!moduleName) {\n      moduleName = `__m${this.moduleCount++}__`;\n      transformNode = this.generateImportTransformNode(moduleName, moduleId);\n    }\n\n    (data as ImportInfoData).moduleName = moduleName;\n    transformNode &&\n      this.importInfos.push({ data: data as ImportInfoData, transformNode });\n\n    this.deferQueue.removes.add(() => state.remove(ancestors));\n    this.deferQueue.exportNamespaces.add({\n      moduleId,\n      namespace,\n      fn: (names) => {\n        names.forEach((name) => {\n          let refNode;\n          if (moduleName) {\n            if (name === namespace) {\n              refNode = callExpression(\n                identifier(Compiler.keys.__GARFISH_NAMESPACE__),\n                [identifier(moduleName)],\n              );\n            } else {\n              refNode = memberExpression(\n                identifier(moduleName),\n                identifier(name),\n              );\n            }\n          }\n          this.exportInfos.push({ refNode, name });\n        });\n      },\n    });\n  }\n\n  // \u5904\u7406\u6240\u6709\u7684 export\n  private exportDeclarationVisitor(\n    node: any,\n    state: State,\n    ancestors: Array<Node>,\n  ) {\n    if (node.declaration) {\n      this.processExportNamedDeclaration(node, state, [...ancestors]);\n    } else if (node.specifiers) {\n      this.processExportSpecifiers(node, state, [...ancestors]);\n    } else if (isExportAllDeclaration(node)) {\n      this.processExportAllDeclaration(node, state, [...ancestors]);\n    }\n  }\n\n  // \u5904\u7406\u6240\u6709\u7528\u5230 esm \u7684\u5F15\u7528\n  private identifierVisitor(\n    node: Identifier,\n    state: State,\n    ancestors: Array<Node>,\n  ) {\n    const parent = ancestors[ancestors.length - 2];\n    if (isExportSpecifier(parent)) return;\n    const scope = state.getScopeByAncestors(ancestors);\n\n    if (scope && this.isReferencedModuleVariable(scope, node)) {\n      ancestors = [...ancestors];\n      this.deferQueue.identifierRefs.add(() => {\n        const replacement = this.generateIdentifierTransformNode(node.name);\n        if (replacement) {\n          state.replaceWith(replacement, ancestors);\n        }\n      });\n    }\n  }\n\n  // Static import expression\n  private importDeclarationVisitor(\n    node: ImportDeclaration,\n    state: State,\n    ancestors: Array<Node>,\n  ) {\n    ancestors = [...ancestors];\n    const moduleId = node.source.value as string;\n    const data = this.getImportInformation(node);\n    let [moduleName, transformNode] = this.findImportInfo(moduleId);\n\n    if (!moduleName) {\n      moduleName = `__m${this.moduleCount++}__`;\n      transformNode = this.generateImportTransformNode(moduleName, moduleId);\n    }\n\n    (data as ImportInfoData).moduleName = moduleName;\n    transformNode &&\n      this.importInfos.push({ data: data as ImportInfoData, transformNode });\n\n    this.deferQueue.removes.add(() => state.remove(ancestors));\n    this.deferQueue.importChecks.add(() =>\n      this.checkImportNames(data.imports, moduleId),\n    );\n  }\n\n  // Dynamic import expression\n  private importExpressionVisitor(\n    node: ImportExpression,\n    state: State,\n    ancestors: Array<Node>,\n  ) {\n    const replacement = callExpression(\n      identifier(Compiler.keys.__GARFISH_DYNAMIC_IMPORT__),\n      [node.source],\n    );\n    state.replaceWith(replacement, ancestors);\n  }\n\n  // `import.meta`\n  private importMetaVisitor(\n    node: MetaProperty,\n    state: State,\n    ancestors: Array<Node>,\n  ) {\n    if (node.meta.name === 'import') {\n      const replacement = memberExpression(\n        identifier(Compiler.keys.__GARFISH_IMPORT_META__),\n        node.property,\n      );\n      state.replaceWith(replacement, ancestors);\n    }\n  }\n\n  private async generateCode() {\n    const nameCounts = {};\n    const getExports = ({ namespace, moduleId }) => {\n      return namespace\n        ? [namespace as string]\n        : this.getChildModuleExports(moduleId) || [];\n    };\n\n    this.deferQueue.exportNamespaces.forEach((val) => {\n      getExports(val).forEach((name) => {\n        if (!nameCounts[name]) {\n          nameCounts[name] = 1;\n        } else {\n          nameCounts[name]++;\n        }\n      });\n    });\n\n    this.deferQueue.exportNamespaces.forEach((val) => {\n      // `export namespace` \u53D8\u91CF\u7684\u53BB\u91CD\n      const exports = getExports(val).filter((name) => {\n        if (name === 'default') return false;\n        if (nameCounts[name] > 1) return false;\n        return this.exportInfos.every((val) => val.name !== name);\n      });\n      val.fn(exports);\n    });\n\n    this.deferQueue.importChecks.forEach((fn) => fn());\n    this.deferQueue.identifierRefs.forEach((fn) => fn());\n    this.deferQueue.replaces.forEach((fn) => fn());\n    this.deferQueue.removes.forEach((fn) => fn());\n    this.generateVirtualModuleSystem();\n\n    const output = generate(this.ast, {\n      sourceMapWithCode: true,\n      sourceMap: this.options.filename,\n      sourceContent: this.options.code,\n    }) as unknown as Output;\n\n    await mergeSourcemap(this, output);\n    return output;\n  }\n\n  transform() {\n    if (this.consumed) {\n      throw new Error('Already consumed');\n    }\n    this.consumed = true;\n    const that = this;\n    const c = (fn) => {\n      return function () {\n        fn.apply(that, arguments);\n      };\n    };\n\n    ancestor(\n      this.ast as unknown as AcornNode,\n      {\n        Identifier: c(this.identifierVisitor),\n        VariablePattern: c(this.identifierVisitor),\n        MetaProperty: c(this.importMetaVisitor),\n        ImportExpression: c(this.importExpressionVisitor),\n        ImportDeclaration: c(this.importDeclarationVisitor),\n        ExportAllDeclaration: c(this.exportDeclarationVisitor),\n        ExportNamedDeclaration: c(this.exportDeclarationVisitor),\n        ExportDefaultDeclaration: c(this.exportDeclarationVisitor),\n      },\n      undefined,\n      this.state,\n    );\n\n    return {\n      generateCode: () => this.generateCode(),\n      exports: this.exportInfos.map((v) => v.name),\n      imports: this.importInfos.map((v) => v.data),\n    };\n  }\n}\n", "// Inspired by `@babel/types`\n// https://babeljs.io/docs/en/babel-parser\n// Filter out ts, jsx related code judgments,\n// and modify the judgments to estree specifications\nimport type {\n  Node,\n  Property,\n  Identifier,\n  RestElement,\n  ForInStatement,\n  ForOfStatement,\n  BlockStatement,\n  LabeledStatement,\n  ArrayPattern,\n  ObjectPattern,\n  AssignmentPattern,\n  ClassDeclaration,\n  CatchClause,\n  VariableDeclaration,\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  ExportSpecifier,\n  ExportAllDeclaration,\n  ExportNamedDeclaration,\n  ExportDefaultDeclaration,\n  ImportDeclaration,\n  ImportDefaultSpecifier,\n  ImportNamespaceSpecifier,\n} from 'estree';\n\nfunction shallowEqual<T extends object>(\n  actual: object,\n  expected: T,\n): actual is T {\n  const keys = Object.keys(expected);\n  for (const key of keys) {\n    if (actual[key] !== expected[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isIdentifier(node?: object): node is Identifier {\n  if (!node) return false;\n  return (node as Node).type === 'Identifier';\n}\n\nexport function isVar(node?: object): node is VariableDeclaration {\n  return isVariableDeclaration(node, { kind: 'var' });\n}\n\nexport function isLet(node?: object) {\n  return isVariableDeclaration(node) && node.kind !== 'var';\n}\n\nexport function isProperty(node?: object): node is Property {\n  if (!node) return false;\n  return (node as Node).type === 'Property';\n}\n\nexport function isBlockScoped(node?: object) {\n  return isFunctionDeclaration(node) || isClassDeclaration(node) || isLet(node);\n}\n\nexport function isArrowFunctionExpression(\n  node?: object,\n): node is ArrowFunctionExpression {\n  if (!node) return false;\n  return (node as Node).type === 'ArrowFunctionExpression';\n}\n\nexport function isForXStatement(\n  node?: object,\n): node is ForInStatement | ForOfStatement {\n  if (!node) return false;\n  const nodeType = (node as Node).type;\n  return 'ForInStatement' === nodeType || 'ForOfStatement' === nodeType;\n}\n\nexport function isBlockStatement(node?: object): node is BlockStatement {\n  if (!node) return false;\n  return (node as Node).type === 'BlockStatement';\n}\n\nexport function isFunctionExpression(\n  node?: object,\n): node is FunctionExpression {\n  if (!node) return false;\n  return (node as Node).type === 'FunctionExpression';\n}\n\nexport function isObjectMethod(node?: object) {\n  if (!node) return false;\n  if (!isProperty(node)) return false;\n  return isFunction(node.value);\n}\n\nexport function isFunction(node?: object) {\n  if (!node) return false;\n  const nodeType = (node as Node).type;\n  if (\n    'FunctionDeclaration' === nodeType ||\n    'FunctionExpression' === nodeType ||\n    'ArrowFunctionExpression' === nodeType ||\n    'MethodDefinition' === nodeType ||\n    // @ts-ignore\n    'ClassPrivateMethod' === nodeType // acorn \u652F\u6301\u79C1\u6709\u5C5E\u6027\u540E\uFF0C\u66FF\u6362\u4E3A estree \u7684\u7C7B\u578B\n  ) {\n    return true;\n  }\n  if (isObjectMethod(node)) return true;\n  return false;\n}\n\nexport function isRestElement(node?: object): node is RestElement {\n  if (!node) return false;\n  return 'RestElement' === (node as Node).type;\n}\n\nexport function isArrayPattern(node?: object): node is ArrayPattern {\n  if (!node) return false;\n  return 'ArrayPattern' === (node as Node).type;\n}\n\nexport function isObjectPattern(node?: object): node is ObjectPattern {\n  if (!node) return false;\n  return 'ObjectPattern' === (node as Node).type;\n}\n\nexport function isAssignmentPattern(node?: object): node is AssignmentPattern {\n  if (!node) return false;\n  return 'AssignmentPattern' === (node as Node).type;\n}\n\nexport function isPattern(\n  node?: object,\n): node is ArrayPattern | ObjectPattern | AssignmentPattern {\n  if (!node) return false;\n  const nodeType = (node as Node).type;\n  if (\n    'AssignmentPattern' === nodeType ||\n    'ArrayPattern' === nodeType ||\n    'ObjectPattern' === nodeType\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isCatchClause(node?: object): node is CatchClause {\n  if (!node) return false;\n  return (node as Node).type === 'CatchClause';\n}\n\nexport function isProgram(node?: object) {\n  if (!node) return false;\n  return (node as Node).type === 'Program';\n}\n\nexport function isFunctionParent(node?: object) {\n  if (!node) return false;\n  const nodeType = (node as Node).type;\n  if (\n    'FunctionDeclaration' === nodeType ||\n    'FunctionExpression' === nodeType ||\n    'ArrowFunctionExpression' === nodeType ||\n    'MethodDefinition' === nodeType ||\n    // @ts-ignore\n    'ClassPrivateMethod' === nodeType ||\n    // @ts-ignore\n    'StaticBlock' === nodeType ||\n    isObjectMethod(node)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isBlockParent(node?: object) {\n  if (!node) return false;\n  const nodeType = (node as Node).type;\n  if (\n    'BlockStatement' === nodeType ||\n    'CatchClause' === nodeType ||\n    'DoWhileStatement' === nodeType ||\n    'ForInStatement' === nodeType ||\n    'ForStatement' === nodeType ||\n    'FunctionDeclaration' === nodeType ||\n    'FunctionExpression' === nodeType ||\n    'Program' === nodeType ||\n    'SwitchStatement' === nodeType ||\n    'WhileStatement' === nodeType ||\n    'ArrowFunctionExpression' === nodeType ||\n    'ForOfStatement' === nodeType ||\n    'MethodDefinition' === nodeType ||\n    isObjectMethod(node) ||\n    // @ts-ignore\n    'ClassPrivateMethod' === nodeType ||\n    // @ts-ignore\n    'StaticBlock' === nodeType\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isLabeledStatement(node?: object): node is LabeledStatement {\n  if (!node) return false;\n  return (node as Node).type === 'LabeledStatement';\n}\n\nexport function isFunctionDeclaration(\n  node?: object,\n): node is FunctionDeclaration {\n  if (!node) return false;\n  return (node as Node).type === 'FunctionDeclaration';\n}\n\nexport function isVariableDeclaration(\n  node?: object,\n  opts?: object,\n): node is VariableDeclaration {\n  if (!node) return false;\n  const nodeType = (node as Node).type;\n  if (nodeType === 'VariableDeclaration') {\n    if (typeof opts === 'undefined') {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n  return false;\n}\n\nexport function isClassDeclaration(node?: object): node is ClassDeclaration {\n  if (!node) return false;\n  return (node as Node).type === 'ClassDeclaration';\n}\n\nexport function isExportAllDeclaration(\n  node?: object,\n): node is ExportAllDeclaration {\n  if (!node) return false;\n  return (node as Node).type === 'ExportAllDeclaration';\n}\n\nexport function isExportDeclaration(\n  node?: object,\n): node is\n  | ExportAllDeclaration\n  | ExportDefaultDeclaration\n  | ExportNamedDeclaration {\n  if (!node) return false;\n  const nodeType = (node as Node).type;\n  if (\n    'ExportAllDeclaration' === nodeType ||\n    'ExportDefaultDeclaration' === nodeType ||\n    'ExportNamedDeclaration' === nodeType\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isExportDefaultDeclaration(\n  node?: object,\n): node is ExportDefaultDeclaration {\n  if (!node) return false;\n  return (node as Node).type === 'ExportDefaultDeclaration';\n}\n\nexport function isExportSpecifier(node?: object): node is ExportSpecifier {\n  if (!node) return false;\n  return (node as Node).type === 'ExportSpecifier';\n}\n\nexport function isImportDeclaration(node?: object): node is ImportDeclaration {\n  if (!node) return false;\n  return (node as Node).type === 'ImportDeclaration';\n}\n\nexport function isImportDefaultSpecifier(\n  node?: object,\n): node is ImportDefaultSpecifier {\n  if (!node) return false;\n  return (node as Node).type === 'ImportDefaultSpecifier';\n}\n\nexport function isImportNamespaceSpecifier(\n  node?: object,\n): node is ImportNamespaceSpecifier {\n  if (!node) return false;\n  return (node as Node).type === 'ImportNamespaceSpecifier';\n}\n\nexport function isDeclaration(node?: object) {\n  if (!node) return false;\n  const nodeType = (node as Node).type;\n  if (\n    'FunctionDeclaration' === nodeType ||\n    'VariableDeclaration' === nodeType ||\n    'ClassDeclaration' === nodeType ||\n    'ExportAllDeclaration' === nodeType ||\n    'ExportDefaultDeclaration' === nodeType ||\n    'ExportNamedDeclaration' === nodeType ||\n    'ImportDeclaration' === nodeType\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isScope(node: Node, parent: Node) {\n  if (isBlockStatement(node) && (isFunction(parent) || isCatchClause(parent))) {\n    return false;\n  }\n  if (isPattern(node) && (isFunction(parent) || isCatchClause(parent))) {\n    return true;\n  }\n  return isScopable(node);\n}\n\nexport function isScopable(node?: object) {\n  if (!node) return false;\n  const nodeType = (node as Node).type;\n  if (\n    'BlockStatement' === nodeType ||\n    'CatchClause' === nodeType ||\n    'DoWhileStatement' === nodeType ||\n    'ForInStatement' === nodeType ||\n    'ForStatement' === nodeType ||\n    'FunctionDeclaration' === nodeType ||\n    'FunctionExpression' === nodeType ||\n    'Program' === nodeType ||\n    'SwitchStatement' === nodeType ||\n    'WhileStatement' === nodeType ||\n    'ArrowFunctionExpression' === nodeType ||\n    'ClassExpression' === nodeType ||\n    'ClassDeclaration' === nodeType ||\n    'ForOfStatement' === nodeType ||\n    'MethodDefinition' === nodeType ||\n    isObjectMethod(node) ||\n    // @ts-ignore\n    'ClassPrivateMethod' === nodeType ||\n    // @ts-ignore\n    'StaticBlock' === nodeType\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isReferenced(node: Node, parent: Node, grandparent: Node) {\n  switch (parent.type) {\n    // yes: PARENT[NODE]\n    // yes: NODE.child\n    // no: parent.NODE\n    case 'MemberExpression':\n    // @ts-ignore\n    case 'OptionalMemberExpression': // acorn \u8FD8\u6CA1\u6709\u5B9E\u73B0\u53EF\u9009\u94FE\n      if (parent.property === node) {\n        return !!parent.computed;\n      }\n      return parent.object === node;\n\n    // no: let NODE = init;\n    // yes: let id = NODE;\n    case 'VariableDeclarator':\n      return parent.init === node;\n\n    // yes: () => NODE\n    // no: (NODE) => {}\n    case 'ArrowFunctionExpression':\n      return parent.body === node;\n\n    // no: class { #NODE; }\n    // no: class { get #NODE() {} }\n    // no: class { #NODE() {} }\n    // no: class { fn() { return this.#NODE; } }\n    // @ts-ignore\n    case 'PrivateName': // acorn \u8FD8\u6CA1\u6709\u5B9E\u73B0\u79C1\u6709\u5C5E\u6027\n      return false;\n\n    // method:\n    //  no: class { NODE() {} }\n    //  yes: class { [NODE]() {} }\n    //  no: class { foo(NODE) {} }\n    // property\n    //  yes: { [NODE]: \"\" }\n    //  no: { NODE: \"\" }\n    //  depends: { NODE }\n    //  depends: { key: NODE }\n    case 'MethodDefinition': // babel \u66FF\u6362\u4E3A\u4E86 ClassMethod\n    // @ts-ignore\n    case 'ClassPrivateMethod': // acorn \u8FD8\u6CA1\u6709\u5B9E\u73B0\u79C1\u6709\u65B9\u6CD5\n    case 'Property':\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      if (isObjectMethod(node)) {\n        return false;\n      } else {\n        // parent.value === node\n        return !grandparent || grandparent.type !== 'ObjectPattern';\n      }\n\n    // no: class { NODE = value; }\n    // yes: class { [NODE] = value; }\n    // yes: class { key = NODE; }\n    // case 'ClassProperty':\n    case 'PropertyDefinition': // acorn \u8FD8\u6CA1\u6709\u5B9E\u73B0\u7C7B\u7684\u5C5E\u6027\u5B9A\u4E49\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return true;\n    // @ts-ignore\n    case 'ClassPrivateProperty': // acorn \u8FD8\u6CA1\u6709\u5B9E\u73B0\n      // @ts-ignore\n      return parent.key !== node;\n\n    // no: class NODE {}\n    // yes: class Foo extends NODE {}\n    case 'ClassDeclaration':\n    case 'ClassExpression':\n      return parent.superClass === node;\n\n    // yes: left = NODE;\n    // no: NODE = right;\n    case 'AssignmentExpression':\n      return parent.right === node;\n\n    // no: [NODE = foo] = [];\n    // yes: [foo = NODE] = [];\n    case 'AssignmentPattern':\n      return parent.right === node;\n\n    // no: NODE: for (;;) {}\n    case 'LabeledStatement':\n      return false;\n\n    // no: try {} catch (NODE) {}\n    case 'CatchClause':\n      return false;\n\n    // no: function foo(...NODE) {}\n    case 'RestElement':\n      return false;\n\n    case 'BreakStatement':\n    case 'ContinueStatement':\n      return false;\n\n    // no: function NODE() {}\n    // no: function foo(NODE) {}\n    case 'FunctionDeclaration':\n    case 'FunctionExpression':\n      return false;\n\n    // no: export NODE from \"foo\";\n    // no: export * as NODE from \"foo\";\n    case 'ExportAllDeclaration':\n      return false;\n\n    // no: export { foo as NODE };\n    // yes: export { NODE as foo };\n    // no: export { NODE as foo } from \"foo\";\n    case 'ExportSpecifier':\n      if ((grandparent as ExportNamedDeclaration)?.source) {\n        return false;\n      }\n      return parent.local === node;\n\n    // no: import NODE from \"foo\";\n    // no: import * as NODE from \"foo\";\n    // no: import { NODE as foo } from \"foo\";\n    // no: import { foo as NODE } from \"foo\";\n    // no: import NODE from \"bar\";\n    case 'ImportDefaultSpecifier':\n    case 'ImportNamespaceSpecifier':\n    case 'ImportSpecifier':\n      return false;\n\n    // no: import \"foo\" assert { NODE: \"json\" }\n    // @ts-ignore\n    case 'ImportAttribute': // acorn \u8FD8\u6CA1\u6709\u5B9E\u73B0\n      return false;\n\n    // no: [NODE] = [];\n    // no: ({ NODE }) = [];\n    case 'ObjectPattern':\n    case 'ArrayPattern':\n      return false;\n\n    // no: new.NODE\n    // no: NODE.target\n    case 'MetaProperty':\n      return false;\n  }\n  return true;\n}\n", "import type {\n  Literal,\n  Property,\n  Identifier,\n  CallExpression,\n  ObjectExpression,\n  MemberExpression,\n  AssignmentExpression,\n  ArrowFunctionExpression,\n  BlockStatement,\n  ExpressionStatement,\n  VariableDeclarator,\n  VariableDeclaration,\n  FunctionDeclaration,\n} from 'estree';\n\nexport function identifier(name: string): Identifier {\n  return { name, type: 'Identifier' };\n}\n\nexport function literal(value: Literal['value']): Literal {\n  return {\n    value,\n    type: 'Literal',\n  } as any;\n}\n\nexport function variableDeclarator(\n  id: VariableDeclarator['id'],\n  init: VariableDeclarator['init'],\n): VariableDeclarator {\n  return {\n    id,\n    init,\n    type: 'VariableDeclarator',\n  };\n}\n\n// kind: 'var' | 'let' | 'const'\nexport function variableDeclaration(\n  kind: VariableDeclaration['kind'],\n  declarations: VariableDeclaration['declarations'],\n): VariableDeclaration {\n  return {\n    kind,\n    declarations,\n    type: 'VariableDeclaration',\n  };\n}\n\nexport function callExpression(\n  callee: CallExpression['callee'],\n  _arguments: CallExpression['arguments'],\n  optional = false,\n): CallExpression {\n  return {\n    callee,\n    optional,\n    arguments: _arguments,\n    type: 'CallExpression',\n  };\n}\n\n// kind: init | get | set\nexport function objectProperty(\n  key: Property['key'],\n  value: Property['value'],\n  kind: Property['kind'] = 'init',\n  method = false,\n  computed = false,\n  shorthand = false,\n  decorators = null,\n): Property {\n  return {\n    key,\n    value,\n    kind,\n    method,\n    computed,\n    shorthand,\n    decorators,\n    type: 'Property',\n  } as any;\n}\n\nexport function arrowFunctionExpression(\n  params: ArrowFunctionExpression['params'],\n  body: ArrowFunctionExpression['body'],\n  async = false,\n  expression = false,\n): ArrowFunctionExpression {\n  return {\n    params,\n    body,\n    async,\n    expression,\n    type: 'ArrowFunctionExpression',\n  };\n}\n\nexport function objectExpression(\n  properties: ObjectExpression['properties'],\n): ObjectExpression {\n  return {\n    properties,\n    type: 'ObjectExpression',\n  };\n}\n\nexport function memberExpression(\n  object: MemberExpression['object'],\n  property: MemberExpression['property'],\n  computed = false,\n  optional = false,\n): MemberExpression {\n  return {\n    object,\n    property,\n    computed,\n    optional,\n    type: 'MemberExpression',\n  };\n}\n\nexport function expressionStatement(\n  expression: ExpressionStatement['expression'],\n  directive: string,\n): ExpressionStatement {\n  const node: any = {\n    expression,\n    type: 'ExpressionStatement',\n  };\n  if (directive) node.directive = directive;\n  return node;\n}\n\nexport function blockStatement(body: BlockStatement['body']): BlockStatement {\n  return {\n    body,\n    type: 'BlockStatement',\n  };\n}\n\nexport function functionDeclaration(\n  id: FunctionDeclaration['id'],\n  params: FunctionDeclaration['params'],\n  body: FunctionDeclaration['body'],\n  generator = false,\n  async = false,\n): FunctionDeclaration {\n  return {\n    id,\n    params,\n    body,\n    async,\n    generator,\n    type: 'FunctionDeclaration',\n  };\n}\n\nexport function assignmentExpression(\n  operator: AssignmentExpression['operator'],\n  left: AssignmentExpression['left'],\n  right: AssignmentExpression['right'],\n): AssignmentExpression {\n  return {\n    operator,\n    left,\n    right,\n    type: 'AssignmentExpression',\n  };\n}\n", "// The version of `source-map` should always be `0.6.1` with escodegen newspaper,\n// otherwise it will package two source code.\nimport {\n  RawSourceMap,\n  SourceMapConsumer,\n  SourceMapGenerator,\n} from 'source-map';\nimport { transformUrl } from '@garfish/utils';\nimport type { Output, Compiler } from './index';\n\nconst PREFIX_REG = /^[#@]\\s?sourceMappingURL\\s?=\\s?/;\n\nfunction merge(oldMap: RawSourceMap, newMap: RawSourceMap) {\n  const oldMapConsumer = new SourceMapConsumer(oldMap);\n  const newMapConsumer = new SourceMapConsumer(newMap);\n  const mergedMapGenerator = new SourceMapGenerator();\n\n  newMapConsumer.eachMapping((m) => {\n    if (!m.originalLine) return;\n    const origPosInOldMap = oldMapConsumer.originalPositionFor({\n      line: m.originalLine,\n      column: m.originalColumn,\n    });\n\n    if (origPosInOldMap.source) {\n      mergedMapGenerator.addMapping({\n        original: {\n          line: origPosInOldMap.line,\n          column: origPosInOldMap.column,\n        },\n        generated: {\n          line: m.generatedLine,\n          column: m.generatedColumn,\n        },\n        name: origPosInOldMap.name,\n        source: origPosInOldMap.source,\n      });\n    }\n  });\n\n  [oldMapConsumer, newMapConsumer].forEach((consumer) => {\n    (consumer as any).sources.forEach((sourceFile: string) => {\n      const sourceContent = consumer.sourceContentFor(sourceFile);\n      if (sourceContent) {\n        mergedMapGenerator.setSourceContent(sourceFile, sourceContent);\n      }\n    });\n  });\n\n  return mergedMapGenerator.toString();\n}\n\nexport async function mergeSourcemap(compiler: Compiler, output: Output) {\n  if (!compiler.sourcemapComment) {\n    output.map = output.map.toString();\n    return;\n  }\n  const newMap = (output.map as any).toJSON();\n  if (!newMap.mappings) {\n    output.map = output.map.toString();\n    return;\n  }\n\n  try {\n    let oldMap;\n    const flag = 'base64,';\n    const mapInfo = compiler.sourcemapComment.trim().replace(PREFIX_REG, '');\n    const index = mapInfo.indexOf(flag);\n\n    if (index > -1) {\n      oldMap = JSON.parse(atob(mapInfo.slice(index + flag.length)));\n    } else {\n      const {\n        filename,\n        runtime: {\n          loader,\n          options: { scope },\n        },\n      } = compiler.options;\n      const requestUrl = transformUrl(filename, mapInfo);\n      const { code } = await loader.load({ scope, url: requestUrl });\n      oldMap = JSON.parse(code);\n    }\n\n    output.map =\n      oldMap && oldMap.mappings ? merge(oldMap, newMap) : output.map.toString();\n  } catch (e) {\n    output.map = output.map.toString();\n    console.warn(e);\n  }\n}\n", "// Inspired by `@babel/traverse`\nimport type { Node, Identifier, Expression } from 'estree';\nimport { base } from 'acorn-walk';\nimport { Scope } from './scope';\nimport { collectorVisitor } from './collectorVisitor';\nimport {\n  isScope,\n  isProgram,\n  isProperty,\n  isIdentifier,\n  isReferenced,\n  isBlockScoped,\n  isDeclaration,\n  isBlockParent,\n  isRestElement,\n  isArrayPattern,\n  isObjectPattern,\n  isAssignmentPattern,\n  isForXStatement,\n  isFunctionParent,\n  isExportDeclaration,\n} from './types';\n\nexport type State = ReturnType<typeof createState>;\n\ntype Assignments = Set<\n  () => {\n    scope: Scope;\n    ids: Array<Identifier>;\n  }\n>;\n\ntype ConstantViolations = Set<\n  () => {\n    scope: Scope;\n    node: Expression;\n  }\n>;\n\ntype References = Set<\n  () => {\n    scope: Scope;\n    ids: Array<Identifier>;\n    type: 'identifier' | 'export';\n  }\n>;\n\nconst virtualTypes = {\n  Declaration: isDeclaration,\n  BlockScoped: isBlockScoped,\n  ForXStatement: isForXStatement,\n  ExportDeclaration: isExportDeclaration,\n};\n\nconst virtualTypesKeys = Object.keys(virtualTypes);\n\nfunction getParentScope(\n  scope: Scope,\n  condition: (node: Node) => boolean,\n): Scope | null {\n  do {\n    if (condition(scope.node)) {\n      return scope;\n    }\n  } while (scope.parent && (scope = scope.parent));\n  return null;\n}\n\nfunction execDeferQueue(state: State) {\n  const programParent = state.programParent;\n  state.defer.assignments.forEach((fn) => {\n    const { ids, scope } = fn();\n    for (const node of ids) {\n      if (!scope.getBinding(node.name)) {\n        programParent?.addGlobal(node);\n      }\n      scope.registerConstantViolation(node.name, node);\n    }\n  });\n  state.defer.references.forEach((fn) => {\n    const { ids, type, scope } = fn();\n    for (const node of ids) {\n      const binding = scope.getBinding(node.name);\n      if (binding) {\n        binding.references.add(node);\n      } else if (type === 'identifier') {\n        programParent?.addGlobal(node);\n      }\n    }\n  });\n  state.defer.constantViolations.forEach((fn) => {\n    const { node, scope } = fn();\n    const ids = getBindingIdentifiers(node);\n    for (const id of ids) {\n      scope.registerConstantViolation(id.name, node);\n    }\n  });\n}\n\nfunction walk(\n  node: Node,\n  visitors: Record<\n    string,\n    (node: Node, state: State, ancestors: Array<Node>) => void\n  >,\n  state: State,\n) {\n  const ancestors: Array<Node> = [];\n  const call = (node: Node, st: State, override?: string) => {\n    const type = override || node.type;\n    const found = visitors[type];\n    const isNew = node !== ancestors[ancestors.length - 1];\n    const isCurrentNode = type === node.type;\n    const virtualFnKeys = virtualTypesKeys.filter((k) => virtualTypes[k](node));\n    if (isNew) ancestors.push(node);\n    if (isCurrentNode) {\n      state.ancestors.set(node, [...ancestors]);\n      const parentNode = ancestors[ancestors.length - 2];\n      let scope = state.scopes.get(parentNode);\n      if (isProgram(node) || isScope(node, parentNode)) {\n        scope = new Scope(node, scope);\n      }\n      scope && state.scopes.set(node, scope);\n    }\n\n    // \u9012\u5F52\u8C03\u7528\n    base[type](node as any, st, call as any);\n\n    if (found) found(node, st || (ancestors as any), ancestors);\n    if (isCurrentNode && virtualFnKeys.length > 0) {\n      for (const key of virtualFnKeys) {\n        const fn = visitors[key];\n        if (fn) fn(node, st || (ancestors as any), ancestors);\n      }\n    }\n    if (isNew) ancestors.pop();\n  };\n  call(node, state);\n}\n\nexport function getBindingIdentifiers(node: Node): Array<Identifier> {\n  const f = (node) => {\n    if (isIdentifier(node)) {\n      return [node];\n    } else if (isArrayPattern(node)) {\n      // @ts-ignore\n      return node.elements.map((el) => f(el)).flat();\n    } else if (isObjectPattern(node)) {\n      // @ts-ignore\n      return node.properties.map((p) => f(p.value)).flat();\n    } else if (isAssignmentPattern(node)) {\n      return f(node.left);\n    } else if (isRestElement(node)) {\n      return f(node.argument);\n    } else {\n      return [];\n    }\n  };\n  return f(node);\n}\n\nexport function createState(ast: Node) {\n  const state = {\n    scopes: new WeakMap<Node, Scope>(),\n    ancestors: new WeakMap<Node, Array<Node>>(),\n    defer: {\n      references: new Set() as References,\n      assignments: new Set() as Assignments,\n      constantViolations: new Set() as ConstantViolations,\n    },\n\n    get programParent() {\n      const scope = state.scopes.get(ast);\n      return scope && this.getProgramParent(scope);\n    },\n\n    getBindingIdentifiers,\n\n    getScopeByAncestors(ancestors: Array<Node>) {\n      let l = ancestors.length;\n      while (~--l) {\n        const scope = this.scopes.get(ancestors[l]);\n        if (scope) return scope;\n      }\n    },\n\n    getFunctionParent(scope: Scope) {\n      return getParentScope(scope, isFunctionParent);\n    },\n\n    getProgramParent(scope: Scope) {\n      const scopeRes = getParentScope(scope, isProgram);\n      if (scopeRes) return scopeRes;\n      // prettier-ignore\n      throw new Error('Couldn\\'t find a Program');\n    },\n\n    getBlockParent(scope: Scope) {\n      const scopeRes = getParentScope(scope, isBlockParent);\n      if (scopeRes) return scopeRes;\n      throw new Error(\n        // prettier-ignore\n        'We couldn\\'t find a BlockStatement, For, Switch, Function, Loop or Program...',\n      );\n    },\n\n    isReferenced(ancestors: Array<Node>) {\n      const l = ancestors.length;\n      return isReferenced(ancestors[l - 1], ancestors[l - 2], ancestors[l - 3]);\n    },\n\n    remove(ancestors: Array<Node>) {\n      this.replaceWith(null, ancestors);\n    },\n\n    replaceWith(replacement: Node | null, ancestors: Array<Node>) {\n      const l = ancestors.length;\n      const node = ancestors[l - 1];\n      if (node === replacement) return;\n      const parent = ancestors[l - 2];\n\n      const set = (obj, key) => {\n        const isProp = isProperty(obj);\n        if (replacement === null) {\n          // \u5220\u9664\u540E\u4F1A\u5F71\u54CD\u904D\u5386\u7684\u987A\u5E8F\uFF0C\u6240\u4EE5 remove \u8981\u5EF6\u65F6\u6267\u884C\n          Array.isArray(obj) ? obj.splice(key, 1) : delete obj[key];\n          if (isProp && obj.shorthand) {\n            delete obj[key === 'key' ? 'value' : 'key'];\n          }\n        } else {\n          obj[key] = replacement;\n          this.ancestors.set(replacement, ancestors);\n          const scopeRes = this.scopes.get(node);\n          scopeRes && this.scopes.set(replacement, scopeRes);\n          if (isProp) {\n            if (isIdentifier(obj.key) && isIdentifier(obj.value)) {\n              if (obj.key.name !== obj.value.name) {\n                obj.shorthand = false;\n              }\n            } else {\n              obj.shorthand = false;\n            }\n          }\n        }\n      };\n\n      for (const key in parent) {\n        const child = parent[key];\n        if (Array.isArray(child)) {\n          const idx = child.indexOf(node);\n          if (idx > -1) set(child, idx);\n        } else {\n          if (child === node) {\n            set(parent, key);\n          }\n        }\n      }\n    },\n  };\n\n  walk(ast, collectorVisitor, state);\n  execDeferQueue(state);\n  return state;\n}\n", "// Inspired by `@babel/traverse`\nimport type {\n  Node,\n  Identifier,\n  LabeledStatement,\n  ExportSpecifier,\n  ExportDefaultDeclaration,\n} from 'estree';\nimport {\n  isPattern,\n  isFunction,\n  isLabeledStatement,\n  isClassDeclaration,\n  isImportDeclaration,\n  isExportDeclaration,\n  isVariableDeclaration,\n  isFunctionDeclaration,\n  isArrowFunctionExpression,\n} from './types';\nimport { getBindingIdentifiers } from './state';\n\ntype BindingKind =\n  | 'var' /* var declarator */\n  | 'let' /* let declarator, class declaration id, catch clause parameters */\n  | 'const' /* const declarator */\n  | 'module' /* import specifiers */\n  | 'hoisted' /* function declaration id */\n  | 'param' /* function declaration parameters */\n  | 'local' /* function expression id, class expression id */\n  | 'unknown'; /* export specifiers */\n\nexport interface Binding {\n  kind: BindingKind;\n  node: Identifier;\n  references: Set<Identifier>;\n  constantViolations: Set<Node>;\n}\n\nexport class Scope {\n  public node: Node;\n  public parent?: Scope;\n  public labels = new Map();\n  public globals = Object.create(null);\n  public bindings = Object.create(null); // \u539F\u578B\u53EA\u80FD\u662F null\n\n  constructor(node: Node, parent?: Scope) {\n    this.node = node;\n    this.parent = parent;\n  }\n\n  private checkBlockScopedCollisions(\n    local: Binding,\n    kind: BindingKind,\n    name: string,\n  ) {\n    if (kind === 'param') return;\n    // \u51FD\u6570\u81EA\u5DF1\u7684\u58F0\u660E\u89C4\u8303\u4E2D\u662F\u4E00\u4E2A\u72EC\u7ACB\u7684\u4F5C\u7528\u57DF\uFF0C\u53EF\u4EE5\u88AB\u8986\u76D6\n    if (local.kind === 'local') return;\n    if (\n      kind === 'let' ||\n      local.kind === 'let' ||\n      local.kind === 'const' ||\n      local.kind === 'module' ||\n      // don't allow a local of param with a kind of let\n      (local.kind === 'param' && kind === 'const')\n    ) {\n      throw new Error(`Duplicate declaration \"${name}\"`);\n    }\n  }\n\n  registerLabel(node: LabeledStatement) {\n    this.labels.set(node.label.name, node);\n  }\n\n  addGlobal(node: Identifier) {\n    this.globals[node.name] = node;\n  }\n\n  reference(name: string, node: Identifier) {\n    const binding = this.getBinding(name);\n    if (binding) {\n      binding.references.add(node);\n    }\n  }\n\n  registerConstantViolation(name: string, node: Node) {\n    const binding = this.getBinding(name);\n    if (binding) {\n      binding.constantViolations.add(node);\n    }\n  }\n\n  getBinding(name: string) {\n    let scope: Scope = this;\n    let previousNode;\n\n    do {\n      const binding = scope.bindings[name];\n      if (binding) {\n        if (\n          isPattern(previousNode) &&\n          binding.kind !== 'param' &&\n          binding.kind !== 'local'\n        ) {\n          // \u8FD9\u91CC\u4E0D\u505A\u4EFB\u4F55\u4E8B\u60C5\n          // \u5982\u679C\u662F pattern \u4E2D\u4F5C\u7528\u57DF\u4E2D\u5F15\u7528\u4E86\u81EA\u8EAB\u6CA1\u5B9A\u4E49\u7684\u53D8\u91CF\uFF0C\u4E0D\u80FD\u5728\u51FD\u6570\u4F53\u5185\u5BFB\u627E\n          // \u4ED6\u662F\u72EC\u7ACB\u7684\u4F5C\u7528\u57DF\uFF0C\u5E76\u4E0D\u662F\u7236\u5B50\u5173\u7CFB\uFF0C\u8FD9\u91CC\u53EA\u662F\u4E3A\u4E86\u6027\u80FD\u5408\u5E76\u5728\u4E86\u4E00\u8D77\uFF0C\u6240\u4EE5\u9700\u8981\u7EE7\u7EED\u5F80\u5916\u627E\u3002\n          // \u4F46\u662F\u6709\u4E24\u79CD\u60C5\u51B5\u7279\u6B8A\n          //  1. param \u662F\u53C2\u6570\uFF0C\u53EF\u4EE5\u88AB\u51FD\u6570\u4F53\u5185\u8BBF\u95EE\n          //  2. local \u662F\u51FD\u6570\u81EA\u8EAB\u7684\u58F0\u660E\uFF0C\u8FD9\u4E2A\u4E00\u5C42\u7684\u4F5C\u7528\u57DF\u4E5F\u662F\u53EF\u4EE5\u88AB\u51FD\u6570\u4F53\u5185\u8BBF\u95EE\u7684\n        } else {\n          return binding;\n        }\n      } else if (\n        !binding &&\n        name === 'arguments' && // arguments \u662F\u4E0D\u53EF\u89C1\u7684\u51FD\u6570\u5185\u90E8\u53C2\u6570\u58F0\u660E\n        isFunction(scope.node) &&\n        isArrowFunctionExpression(scope.node)\n      ) {\n        break;\n      }\n      previousNode = scope.node;\n    } while (scope.parent && (scope = scope.parent));\n  }\n\n  registerBinding(kind: BindingKind, name: string, node: Node) {\n    if (!kind) throw new ReferenceError('no `kind`');\n    const binding = this.bindings[name];\n\n    if (binding) {\n      // \u904D\u5386\u7684\u65F6\u5019\u4F1A\u6709\u91CD\u590D\u585E\u5165\n      if (binding.node === node) return;\n      // \u68C0\u67E5\u4F5C\u7528\u57DF\u7684\u78B0\u649E\n      this.checkBlockScopedCollisions(binding, kind, name);\n      // \u5982\u679C\u987A\u5229\u901A\u8FC7\uFF0C\u5219\u4EE3\u8868\u88AB\u66F4\u6539\u4E86\uFF0C\u91CD\u590D\u7684\u58F0\u660E\u4E5F\u662F\u66F4\u6539\n      this.registerConstantViolation(name, node);\n    } else {\n      // \u6211\u4EEC\u7684\u6848\u4F8B\u662F esModule, \u91CC\u9762\u4E0D\u53EF\u80FD\u6709 with \u8868\u8FBE\u5F0F\n      this.bindings[name] = {\n        kind,\n        node,\n        references: new Set(),\n        constantViolations: new Set(),\n      };\n    }\n  }\n\n  // @babel/types/src/retrievers/getBindingIdentifiers.ts\n  registerDeclaration(node: Node) {\n    if (isLabeledStatement(node)) {\n      this.registerLabel(node);\n    } else if (isFunctionDeclaration(node)) {\n      node.id && this.registerBinding('hoisted', node.id.name, node);\n    } else if (isVariableDeclaration(node)) {\n      const { declarations } = node;\n      for (const decl of declarations) {\n        // node.kind \u6709 `var`, `let`, `const`\n        const ids = getBindingIdentifiers(decl.id);\n        for (const { name } of ids) {\n          this.registerBinding(node.kind, name, decl);\n        }\n      }\n    } else if (isClassDeclaration(node)) {\n      node.id && this.registerBinding('let', node.id.name, node);\n    } else if (isImportDeclaration(node)) {\n      const specifiers = node.specifiers;\n      for (const specifier of specifiers) {\n        this.registerBinding('module', specifier.local.name, specifier);\n      }\n    } else if (isExportDeclaration(node)) {\n      const { declaration } = node as ExportDefaultDeclaration;\n      if (\n        isClassDeclaration(declaration) ||\n        isFunctionDeclaration(declaration) ||\n        isVariableDeclaration(declaration)\n      ) {\n        this.registerDeclaration(declaration);\n      }\n    } else {\n      this.registerBinding(\n        'unknown',\n        (node as ExportSpecifier).exported.name,\n        node,\n      );\n    }\n  }\n}\n", "// Inspired by `@babel/traverse`\nimport type {\n  Node,\n  Function,\n  Identifier,\n  CatchClause,\n  ForStatement,\n  ForInStatement,\n  ForOfStatement,\n  LabeledStatement,\n  UnaryExpression,\n  ClassExpression,\n  UpdateExpression,\n  AssignmentExpression,\n  ImportDeclaration,\n  ExportAllDeclaration,\n  ExportNamedDeclaration,\n  ExportDefaultDeclaration,\n} from 'estree';\nimport type { State } from './state';\nimport {\n  isVar,\n  isPattern,\n  isIdentifier,\n  isBlockScoped,\n  isClassDeclaration,\n  isImportDeclaration,\n  isExportDeclaration,\n  isFunctionDeclaration,\n  isExportAllDeclaration,\n  isFunctionExpression,\n  isVariableDeclaration,\n} from './types';\n\nexport const collectorVisitor = {\n  ForStatement(node: ForStatement, state: State) {\n    const { init } = node;\n    if (init && isVar(init)) {\n      const scope = state.scopes.get(node);\n      const parentScope =\n        scope &&\n        (state.getFunctionParent(scope) || state.getProgramParent(scope));\n      for (const decl of init.declarations) {\n        const ids = state.getBindingIdentifiers(decl.id);\n        for (const { name } of ids) {\n          parentScope && parentScope.registerBinding('var', name, decl);\n        }\n      }\n    }\n  },\n\n  Declaration(node: Node, state: State) {\n    if (isBlockScoped(node)) return;\n    if (isImportDeclaration(node)) return;\n    if (isExportDeclaration(node)) return;\n    const scope = state.scopes.get(node);\n    const parent =\n      scope &&\n      (state.getFunctionParent(scope) || state.getProgramParent(scope));\n    parent && parent.registerDeclaration(node);\n  },\n\n  BlockScoped(node: Node, state: State) {\n    let scope = state.scopes.get(node);\n    if (scope && scope.node === node) scope = scope.parent;\n    const parent = scope && state.getBlockParent(scope);\n    parent && parent.registerDeclaration(node);\n  },\n\n  ImportDeclaration(node: ImportDeclaration, state: State) {\n    const scope = state.scopes.get(node);\n    const parent = scope && state.getBlockParent(scope);\n    parent && parent.registerDeclaration(node);\n  },\n\n  Identifier(node: Identifier, state: State, ancestors: Array<Node>) {\n    if (state.isReferenced(ancestors)) {\n      const scope = state.scopes.get(node);\n      scope &&\n        state.defer.references.add(() => {\n          const ids = state.getBindingIdentifiers(node);\n          return { scope, ids, type: 'identifier' };\n        });\n    }\n  },\n\n  ForXStatement(node: ForInStatement | ForOfStatement, state: State) {\n    const scope = state.scopes.get(node);\n    const { left } = node;\n    if (isPattern(left) || isIdentifier(left)) {\n      const ids = state.getBindingIdentifiers(left);\n      for (const { name } of ids) {\n        scope && scope.registerConstantViolation(name, node);\n      }\n    } else if (isVar(left)) {\n      const parentScope =\n        scope &&\n        (state.getFunctionParent(scope) || state.getProgramParent(scope));\n      for (const decl of left.declarations) {\n        const ids = state.getBindingIdentifiers(decl.id);\n        for (const { name } of ids) {\n          parentScope && parentScope.registerBinding('var', name, decl);\n        }\n      }\n    }\n  },\n\n  // `acorn` Identifier \u6CA1\u6709\u7B97\u4E0A ExportNamedDeclaration \u4E2D\u7684\u503C\n  ExportNamedDeclaration(node: ExportNamedDeclaration, state: State) {\n    const { specifiers } = node;\n    if (specifiers && specifiers.length > 0) {\n      for (const { local } of specifiers) {\n        const scope = state.scopes.get(node);\n        scope &&\n          state.defer.references.add(() => {\n            const ids = state.getBindingIdentifiers(local);\n            return { scope, ids, type: 'identifier' };\n          });\n      }\n    }\n  },\n\n  ExportDeclaration(\n    node:\n      | ExportAllDeclaration\n      | ExportDefaultDeclaration\n      | ExportNamedDeclaration,\n    state: State,\n  ) {\n    // ExportAllDeclaration does not have `declaration`\n    if (isExportAllDeclaration(node)) return;\n    const { declaration } = node as ExportNamedDeclaration;\n    const scope = state.scopes.get(node);\n    if (\n      declaration &&\n      (isClassDeclaration(declaration) || isFunctionDeclaration(declaration))\n    ) {\n      const { id } = declaration;\n      if (!id) return;\n      const ids = state.getBindingIdentifiers(id);\n      scope &&\n        state.defer.references.add(() => {\n          return { ids, scope, type: 'export' };\n        });\n    } else if (declaration && isVariableDeclaration(declaration)) {\n      for (const decl of declaration.declarations) {\n        scope &&\n          state.defer.references.add(() => {\n            const ids = state.getBindingIdentifiers(decl.id);\n            return { ids, scope, type: 'export' };\n          });\n      }\n    }\n  },\n\n  LabeledStatement(node: LabeledStatement, state: State) {\n    const scope = state.scopes.get(node);\n    if (scope) {\n      const parent = state.getBlockParent(scope);\n      parent.registerDeclaration(node);\n    }\n  },\n\n  AssignmentExpression(node: AssignmentExpression, state: State) {\n    const scope = state.scopes.get(node);\n    scope &&\n      state.defer.assignments.add(() => {\n        return { scope, ids: state.getBindingIdentifiers(node.left) };\n      });\n  },\n\n  UpdateExpression(node: UpdateExpression, state: State) {\n    const scope = state.scopes.get(node);\n    scope &&\n      state.defer.constantViolations.add(() => {\n        return { scope, node: node.argument };\n      });\n  },\n\n  UnaryExpression(node: UnaryExpression, state: State) {\n    if (node.operator === 'delete') {\n      const scope = state.scopes.get(node);\n      scope &&\n        state.defer.constantViolations.add(() => {\n          return { scope, node: node.argument };\n        });\n    }\n  },\n\n  CatchClause(node: CatchClause, state: State) {\n    const scope = state.scopes.get(node);\n    const ids = node.param && state.getBindingIdentifiers(node.param);\n    if (ids) {\n      for (const { name } of ids) {\n        scope && scope.registerBinding('let', name, node);\n      }\n    }\n  },\n\n  Function(node: Function, state: State) {\n    const { params } = node;\n    const scope = state.scopes.get(node);\n    for (const param of params) {\n      const ids = state.getBindingIdentifiers(param);\n      for (const { name } of ids) {\n        scope && scope.registerBinding('param', name, param);\n      }\n    }\n    // Register function expression id after params. When the id\n    // collides with a function param, the id effectively can't be\n    // referenced: here we registered it as a constantViolation\n    if (isFunctionExpression(node) && node.id) {\n      scope && scope.registerBinding('local', node.id.name, node);\n    }\n  },\n\n  ClassExpression(node: ClassExpression, state: State) {\n    const { id } = node;\n    const scope = state.scopes.get(node);\n    if (id) {\n      scope && scope.registerBinding('local', id.name, node);\n    }\n  },\n};\n", "export type MemoryModule = Record<string, any>;\n\nexport type MetaObject = { url: string; __garfishPolyfill__: boolean };\n\nexport type Module = {\n  [key: string]: any;\n  [Symbol.toStringTag]: 'Module';\n};\n\nfunction Module() {}\n\nexport function createModule(memoryModule: MemoryModule) {\n  const module: Module = new Module();\n  Object.setPrototypeOf(module, null);\n  Object.defineProperty(module, Symbol.toStringTag, {\n    value: 'Module',\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  });\n\n  Object.keys(memoryModule).forEach((key) => {\n    const descriptor = Object.getOwnPropertyDescriptor(memoryModule, key);\n    if (!descriptor) {\n      throw TypeError(`can't get ${key} descriptor`);\n    }\n    const getter = descriptor.get;\n    Object.defineProperty(module, key, {\n      enumerable: true,\n      configurable: false,\n      get: getter,\n      set: () => {\n        throw TypeError(\n          `Cannot assign to read only property '${key}' of object '[object Module]`,\n        );\n      },\n    });\n  });\n\n  Object.seal(module);\n  return module;\n}\n\nexport function createImportMeta(url: string) {\n  const metaObject: MetaObject = Object.create(null);\n  const set = (key, value) => {\n    Object.defineProperty(metaObject, key, {\n      value,\n      writable: true,\n      enumerable: true,\n      configurable: true,\n    });\n  };\n\n  set('url', url);\n  set('__garfishPolyfill__', true);\n  return { meta: metaObject };\n}\n", "import { evalWithEnv } from '@garfish/utils';\nimport type { interfaces } from '@garfish/core';\nimport { Runtime } from './runtime';\n\nexport interface Options {\n  excludes?: Array<string> | ((name: string) => boolean);\n}\n\nexport function GarfishEsModule(options: Options = {}) {\n  return function (Garfish: interfaces.Garfish): interfaces.Plugin {\n    const appModules = {};\n    const { excludes } = options;\n\n    const disable = (\n      appId: number,\n      appName: string,\n      appInfo: interfaces.AppInfo,\n    ) => {\n      if (appModules[appId]) return true;\n      if (Array.isArray(excludes)) return excludes.includes(appName);\n      if (typeof excludes === 'function') return excludes(appName);\n      if (appInfo.sandbox === false || appInfo?.sandbox?.open === false) {\n        return true;\n      }\n      return false;\n    };\n\n    return {\n      name: 'es-module',\n\n      afterLoad(appInfo, appInstance) {\n        if (!appInstance) return;\n        const { appId, name } = appInstance;\n        if (!disable(appId, name, appInfo)) {\n          // @ts-ignore\n          const sandbox = appInstance.vmSandbox;\n          const runtime = new Runtime({ scope: name });\n\n          appModules[appId] = runtime;\n          runtime.loader = Garfish.loader;\n\n          appInstance.runCode = function (\n            code: string,\n            env: Record<string, any>,\n            url?: string,\n            options?: interfaces.ExecScriptOptions,\n          ) {\n            const appEnv = appInstance.getExecScriptEnv(options?.noEntry);\n            Object.assign(env, appEnv);\n\n            if (options?.isModule) {\n              const codeRef = { code };\n\n              runtime.options.execCode = function (output, provider) {\n                const sourcemap = `\\n//@ sourceMappingURL=${output.map}`;\n                Object.assign(env, provider);\n                codeRef.code = `(() => {'use strict';${output.code}})()`;\n\n                sandbox?.hooks.lifecycle.beforeInvoke.emit(\n                  codeRef,\n                  url,\n                  env,\n                  options,\n                );\n\n                try {\n                  const params = sandbox?.createExecParams(codeRef, env);\n                  const code = `${codeRef.code}\\n//${output.storeId}${sourcemap}`;\n                  evalWithEnv(code, params || {}, undefined, false);\n                } catch (e) {\n                  sandbox?.processExecError(e, url, env, options);\n                }\n\n                sandbox?.hooks.lifecycle.afterInvoke.emit(\n                  codeRef,\n                  url,\n                  env,\n                  options,\n                );\n              };\n\n              if (url) {\n                appInstance.esmQueue.add(async (next) => {\n                  options.isInline\n                    ? await runtime.importByCode(codeRef.code, url)\n                    : await runtime.importByUrl(url, url);\n                  next();\n                });\n              }\n            } else {\n              sandbox?.execScript(code, env, url, options);\n            }\n          };\n        }\n      },\n\n      afterUnmount(appInfo, appInstance, isCacheMode) {\n        if (!isCacheMode) {\n          appModules[appInstance.appId] = null;\n        }\n      },\n    };\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
