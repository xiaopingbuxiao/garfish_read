{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/config.ts", "../../src/utils/urlUt.ts", "../../src/utils/index.ts", "../../src/utils/customEvent.ts", "../../src/utils/navEvent.ts", "../../src/linkTo.ts", "../../src/agentRouter.ts", "../../src/context.ts"],
  "sourcesContent": ["import type { interfaces } from '@garfish/core';\nimport { createKey, routerLog } from '@garfish/utils';\nimport { RouterConfig } from './config';\nimport router, {\n  initRedirect,\n  RouterInterface,\n  listenRouterAndReDirect,\n} from './context';\n\ndeclare module '@garfish/core' {\n  export default interface Garfish {\n    router: RouterInterface;\n    apps: Record<string, interfaces.App>;\n  }\n\n  export namespace interfaces {\n    export interface Config {\n      autoRefreshApp?: boolean;\n      onNotMatchRouter?: (path: string) => Promise<void> | void;\n    }\n\n    export interface AppInfo {\n      activeWhen?: string | ((path: string) => boolean); // \u624B\u52A8\u52A0\u8F7D\uFF0C\u53EF\u4E0D\u586B\u5199\u8DEF\u7531\n      active?: (appInfo: AppInfo, rootPath: string) => void;\n      deactive?: (appInfo: AppInfo, rootPath: string) => void;\n      rootPath?: string;\n      basename?: string;\n    }\n  }\n}\n\nexport type { RouterInterface } from './context';\n\ninterface Options {\n  autoRefreshApp?: boolean;\n  onNotMatchRouter?: (path: string) => Promise<void> | void;\n}\n\nexport function GarfishRouter(_args?: Options) {\n  return function (Garfish: interfaces.Garfish): interfaces.Plugin {\n    Garfish.apps = {};\n    Garfish.router = router;\n\n    return {\n      name: 'router',\n      version: '1.12.0',\n\n      bootstrap(options: interfaces.Options) {\n        let activeApp: null | string = null;\n        const unmounts: Record<string, Function> = {};\n        const { basename } = options;\n        const { autoRefreshApp = true, onNotMatchRouter = () => null } =\n          Garfish.options;\n\n        async function active(\n          appInfo: interfaces.AppInfo,\n          rootPath: string = '/',\n        ) {\n          routerLog(`${appInfo.name} active`, {\n            appInfo,\n            rootPath,\n            listening: RouterConfig.listening,\n          });\n\n          // In the listening state, trigger the rendering of the application\n          if (!RouterConfig.listening) return;\n\n          const { name, active, cache = true } = appInfo;\n          if (active) return active(appInfo, rootPath);\n          appInfo.rootPath = rootPath;\n\n          const currentApp = (activeApp = createKey());\n          const app = await Garfish.loadApp(appInfo.name, {\n            cache,\n            basename: rootPath,\n            entry: appInfo.entry,\n            domGetter: appInfo.domGetter,\n          });\n\n          if (app) {\n            app.appInfo.basename = rootPath;\n\n            const call = async (app: interfaces.App, isRender: boolean) => {\n              if (!app) return;\n              const isDes = cache && app.mounted;\n              if (isRender) {\n                return await app[isDes ? 'show' : 'mount']();\n              } else {\n                return app[isDes ? 'hide' : 'unmount']();\n              }\n            };\n\n            Garfish.apps[name] = app;\n            unmounts[name] = () => {\n              // Destroy the application during rendering and discard the application instance\n              if (app.mounting) {\n                delete Garfish.cacheApps[name];\n              }\n              call(app, false);\n            };\n\n            if (currentApp === activeApp) {\n              await call(app, true);\n            }\n          }\n        }\n\n        async function deactive(appInfo: interfaces.AppInfo, rootPath: string) {\n          routerLog(`${appInfo.name} deactive`, {\n            appInfo,\n            rootPath,\n          });\n\n          activeApp = null;\n          const { name, deactive } = appInfo;\n          if (deactive) return deactive(appInfo, rootPath);\n\n          const unmount = unmounts[name];\n          unmount && unmount();\n          delete Garfish.apps[name];\n\n          // Nested scene to remove the current application of nested data\n          // To avoid the main application prior to application\n          const needToDeleteApps = router.routerConfig.apps.filter((app) => {\n            if (appInfo.rootPath === app.basename) return true;\n          });\n          if (needToDeleteApps.length > 0) {\n            needToDeleteApps.forEach((app) => {\n              delete Garfish.appInfos[app.name];\n              delete Garfish.cacheApps[app.name];\n            });\n            router.setRouterConfig({\n              apps: router.routerConfig.apps.filter((app) => {\n                return !needToDeleteApps.some(\n                  (needDelete) => app.name === needDelete.name,\n                );\n              }),\n            });\n          }\n        }\n\n        const apps = Object.values(Garfish.appInfos);\n\n        const appList = apps.filter((app) => {\n          if (!app.basename) app.basename = basename;\n          return !!app.activeWhen;\n        }) as Array<Required<interfaces.AppInfo>>;\n\n        const listenOptions = {\n          basename,\n          active,\n          deactive,\n          autoRefreshApp,\n          notMatch: onNotMatchRouter,\n          apps: appList,\n          listening: true,\n        };\n        routerLog('listenRouterAndReDirect', listenOptions);\n        listenRouterAndReDirect(listenOptions);\n      },\n\n      registerApp(appInfos) {\n        const appList = Object.values(appInfos);\n        // @ts-ignore\n        router.registerRouter(appList.filter((app) => !!app.activeWhen));\n        // After completion of the registration application, trigger application mount\n        // Has been running after adding routing to trigger the redirection\n        if (!Garfish.running) return;\n        routerLog('registerApp initRedirect', appInfos);\n        initRedirect();\n      },\n    };\n  };\n}\n", "import { interfaces } from '@garfish/core';\n\nexport type RouterHook = (\n  to: CurrentRouterInfo,\n  from: CurrentRouterInfo,\n  next,\n) => void;\n\nexport type RouterChange = (path: string) => void;\n\nexport interface RouterInfo {\n  fullPath: string;\n  path: string;\n  query: Object;\n  state: Object;\n}\n\nexport interface CurrentRouterInfo extends RouterInfo {\n  matched: Array<interfaces.AppInfo>;\n}\n\n// Don't change the logo, in order to avoid inconsistent version leads to failure\nexport const __GARFISH_ROUTER_UPDATE_FLAG__ = '__GARFISH_ROUTER_UPDATE_FLAG__';\n\nexport const __GARFISH_ROUTER_FLAG__ = '__GARFISH_ROUTER_FLAG__';\n\nexport const __GARFISH_BEFORE_ROUTER_EVENT__ = 'garfish:before-routing-event';\n\nexport interface Options {\n  basename?: string;\n  listening?: boolean;\n  current?: CurrentRouterInfo;\n  autoRefreshApp?: boolean;\n  apps: Array<interfaces.AppInfo>;\n  beforeEach?: RouterHook;\n  afterEach?: RouterHook;\n  routerChange?: (url: string) => void;\n  active: (\n    appInfo: interfaces.AppInfo,\n    rootPath: string | undefined,\n  ) => Promise<void>;\n  deactive: (\n    appInfo: interfaces.AppInfo,\n    rootPath: string | undefined,\n  ) => Promise<void>;\n  notMatch?: (path: string) => void;\n}\n\nexport const RouterConfig: Options = {\n  basename: '/',\n  current: {\n    fullPath: '/',\n    path: '/',\n    matched: [],\n    query: {},\n    state: {},\n  },\n  apps: [],\n  beforeEach: (to, from, next) => next(),\n  afterEach: (to, from, next) => next(),\n  active: () => Promise.resolve(),\n  deactive: () => Promise.resolve(),\n  routerChange: () => {},\n  autoRefreshApp: true,\n  listening: true,\n};\n\nexport function set<T extends keyof Options>(field: T, value: Options[T]) {\n  RouterConfig[field] = value;\n}\n\nexport function get(field: keyof Options) {\n  return RouterConfig[field];\n}\n\nexport function setRouterConfig(options: Partial<Options>) {\n  Object.assign(RouterConfig, options);\n}\n", "import { interfaces } from '@garfish/core';\n\nexport function formatQuery(query: { [props: string]: string } = {}) {\n  const qs = Object.keys(query)\n    .map((key) => `${key}=${query[key]}`)\n    .join('&');\n  return qs ? '?' + qs : '';\n}\n\nexport function parseQuery(query = '') {\n  const res: { [props: string]: string[] } = {};\n  if (query) {\n    query\n      .slice(1)\n      .split('&')\n      .map((item) => {\n        const pairs = item.split('=');\n        res[pairs[0]] = pairs;\n      });\n  }\n  return res;\n}\n\n/**\n * \u89E3\u6790\u51FA\u5B50\u5E94\u7528\u7684\u6839\u8DEF\u7531,\u53D6\u5F97app1\n * \u89E3\u6790\u5185\u5BB9\uFF1A\n *    /basename/app1/about\u3001basename/app1\u3001basename/app1/\u3001/app1/\u3001/app1/about\u3001app1/\n *    #/app1\u3001/#/app1/\u3001/#/app1/detail/\u3001/#/app1/detail\n * @param path\n */\nexport function parsePath(path: string) {\n  const matches = path.match(new RegExp('^/([^/]+)')) || [];\n  return `/${matches[1] || ''}`;\n}\n\nexport function find(arr: Array<Function>, func: Function) {\n  for (let i = 0; i < arr.length; i++) {\n    if (func(arr[i])) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n\nexport function getPath(basename: string = '/', pathname?: string) {\n  if (basename === '/' || basename === '') {\n    return pathname || location.pathname;\n  } else {\n    return (pathname || location.pathname).replace(\n      new RegExp(`^/?${basename}`),\n      '',\n    );\n  }\n}\n\nexport function getAppRootPath(appInfo: interfaces.AppInfo) {\n  const path = getPath(appInfo.basename, location.pathname);\n  let appRootPath = appInfo.basename === '/' ? '' : (appInfo.basename || '');\n  if (typeof appInfo.activeWhen === 'string') {\n    appRootPath += appInfo.activeWhen;\n  } else {\n    appRootPath += path.split('').reduce((pre, next) => {\n      // \u5339\u914D\n      if (typeof appInfo.activeWhen === 'function' && !appInfo.activeWhen(pre))\n        return pre + next;\n      return pre;\n    }, '');\n  }\n  return appRootPath;\n}\n", "import { RouterHook } from '../config';\n\nexport async function asyncForEach<T>(\n  arr: T[],\n  callback: (v: T, k: number, O: T[]) => Promise<any>,\n) {\n  const length = arr.length;\n  let k = 0;\n  while (k < length) {\n    const kValue = arr[k];\n    await callback(kValue, k, arr);\n    k++;\n  }\n}\n\nexport function toMiddleWare(to, from, cb: RouterHook) {\n  return new Promise((resolve, reject) => {\n    try {\n      cb(to, from, resolve);\n    } catch (err) {\n      reject(err);\n    }\n  });\n}\n\nexport function createEvent(type) {\n  let e;\n  // Compatible with ie\n  if (\n    navigator.userAgent.indexOf('MSIE') !== -1 ||\n    navigator.appVersion.indexOf('Trident/') > 0\n  ) {\n    e = document.createEvent('UIEvents');\n    e.initUIEvent(type.toLowerCase(), true, false, window, 0);\n  } else {\n    e = new Event(type.toLowerCase());\n  }\n  return e;\n}\n", "// copy from https://github.com/webmodules/custom-event\n\nconst NativeCustomEvent =\n  typeof global !== 'undefined' ? (global as any)?.CustomEvent : null;\n\nfunction useNative() {\n  try {\n    const p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });\n    return 'cat' === p.type && 'bar' === p.detail.foo;\n  } catch (e) {}\n  return false;\n}\n\nlet CustomEvent: any;\n\nif (NativeCustomEvent && useNative()) {\n  CustomEvent = NativeCustomEvent;\n} else if (\n  'undefined' !== typeof document &&\n  'function' === typeof document.createEvent\n) {\n  // IE >= 9\n  CustomEvent = function (type, params) {\n    params = params || { bubbles: false, cancelable: false, detail: null };\n    const evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(\n      type,\n      params.bubbles || false,\n      params.cancelable || false,\n      params.detail || null,\n    );\n    return evt;\n  };\n} else {\n  // IE <= 8\n  CustomEvent = function (type, params) {\n    const e = (document as any).createEventObject();\n    e.type = type;\n    if (params) {\n      e.bubbles = Boolean(params.bubbles);\n      e.cancelable = Boolean(params.cancelable);\n      e.detail = params.detail;\n    } else {\n      e.bubbles = false;\n      e.cancelable = false;\n      e.detail = void 0;\n    }\n    return e;\n  };\n}\n\nexport default CustomEvent;\n", "import { validURL } from '@garfish/utils';\nimport { RouterConfig, __GARFISH_ROUTER_UPDATE_FLAG__ } from '../config';\n\nfunction createPopStateEvent(state: any, originalMethodName: string) {\n  let evt;\n  try {\n    evt = new PopStateEvent('popstate', { state });\n  } catch (err) {\n    // IE 11 compatibility\n    evt = document.createEvent('PopStateEvent');\n    (evt as any).initPopStateEvent('popstate', false, false, state);\n  }\n  (evt as any).garfish = true;\n  (evt as any).garfishTrigger = originalMethodName;\n  return evt;\n}\n\nexport const callCapturedEventListeners = (type: keyof History) => {\n  const eventArguments = createPopStateEvent(window.history.state, type);\n  window.dispatchEvent(eventArguments);\n};\n\nconst handlerParams = function (\n  path: string,\n  query: { [key: string]: string },\n  basename?: string,\n): string {\n  if (!path || typeof path !== 'string') return '';\n  let url = path;\n  if (url[0] !== '/') url = '/' + url;\n  if (Object.prototype.toString.call(query) === '[object Object]') {\n    const qs = Object.keys(query)\n      .map((key) => `${key}=${query[key]}`)\n      .join('&');\n    url += qs ? '?' + qs : '';\n  }\n  if (basename !== '/') url = basename + url;\n  if (url[0] !== '/') url = '/' + url;\n  return url;\n};\n\nexport const push = ({\n  path,\n  query,\n  basename,\n}: {\n  path: string;\n  query?: { [key: string]: string };\n  basename?: string;\n}) => {\n  if (!basename) basename = RouterConfig.basename || '/';\n\n  let url: string | null = null;\n  if (validURL(path)) {\n    url = /(^https?:)|(^\\/\\/)/.test(path) ? path : `//${path}`;\n  } else {\n    url = handlerParams(path, query!, basename);\n  }\n  // \u4E0D\u4FDD\u7559\u4E4B\u524Dhistory.state\u7684\u72B6\u6001\u4F1A\u5BFC\u81F4vue3\u4F9D\u8D56state\u7684\u60C5\u51B5\u65E0\u6CD5\u6B63\u5E38\u6E32\u67D3\u9875\u9762\n  history.pushState(\n    { [__GARFISH_ROUTER_UPDATE_FLAG__]: true, ...history.state },\n    '',\n    url,\n  );\n};\n\nexport const replace = ({\n  path,\n  query,\n  basename,\n}: {\n  path: string;\n  query?: { [key: string]: string };\n  basename?: string;\n}) => {\n  if (!basename) basename = RouterConfig.basename || '/';\n\n  let url: string | null = null;\n  if (validURL(path)) {\n    url = /^(https?:)(\\/\\/)/.test(path) ? path : `//${path}`;\n  } else {\n    url = handlerParams(path, query!, basename);\n  }\n  history.replaceState(\n    { [__GARFISH_ROUTER_UPDATE_FLAG__]: true, ...history.state },\n    '',\n    url,\n  );\n};\n", "import { parseQuery, getAppRootPath, getPath } from './utils/urlUt';\nimport { callCapturedEventListeners } from './utils/navEvent';\nimport { asyncForEach, toMiddleWare } from './utils';\nimport {\n  RouterConfig,\n  setRouterConfig,\n  RouterInfo,\n  __GARFISH_ROUTER_UPDATE_FLAG__,\n  __GARFISH_ROUTER_FLAG__,\n  __GARFISH_BEFORE_ROUTER_EVENT__,\n} from './config';\n\n// Inspection application is activated\nconst hasActive = (activeWhen: any, path: string) => {\n  if (typeof activeWhen === 'string') {\n    if (activeWhen[0] !== '/') activeWhen = `/${activeWhen}`;\n    // Set to the root path must be congruent\n    if (activeWhen === '/' && path === activeWhen) return true;\n\n    const activeWhenArr = activeWhen.split('/');\n    const pathArr = path.split('/');\n    let flag: boolean = true;\n    activeWhenArr.forEach((pathItem: string, index: number) => {\n      if (pathItem && pathItem !== pathArr[index]) {\n        flag = false;\n      }\n    });\n    return flag;\n  } else {\n    return activeWhen(path);\n  }\n};\n\n// Overloading to specify the routing\n// 1. Applications for current needs to be destroyed\n// 2. Gets the current need to activate the application\n// 3. To acquire new need to activate the application\n// 4. Trigger function beforeEach, trigger in front of the destroyed all applications\n// 5. Trigger the need to destroy deactive function of application\n// 6. If there is no need to activate the application, by default, triggering popstate application component view child to update\nexport const linkTo = async ({\n  toRouterInfo,\n  fromRouterInfo,\n  eventType,\n}: {\n  toRouterInfo: RouterInfo;\n  fromRouterInfo: RouterInfo;\n  eventType: keyof History | 'popstate';\n}) => {\n  const {\n    current,\n    apps,\n    deactive,\n    active,\n    notMatch,\n    beforeEach,\n    afterEach,\n    autoRefreshApp,\n  } = RouterConfig;\n\n  const deactiveApps = current!.matched.filter(\n    (appInfo) =>\n      !hasActive(\n        appInfo.activeWhen,\n        getPath(appInfo.basename, location.pathname),\n      ),\n  );\n\n  // Activate the corresponding application\n  const activeApps = apps.filter((appInfo) => {\n    return hasActive(\n      appInfo.activeWhen,\n      getPath(appInfo.basename, location.pathname),\n    );\n  });\n\n  const needToActive = activeApps.filter(({ name }) => {\n    return !current!.matched.some(({ name: cName }) => name === cName);\n  });\n\n  // router infos\n  const to = {\n    ...toRouterInfo,\n    matched: needToActive,\n  };\n\n  const from = {\n    ...fromRouterInfo,\n    matched: deactiveApps,\n  };\n\n  await toMiddleWare(to, from, beforeEach!);\n\n  // Pause the current application of active state\n  if (current!.matched.length > 0) {\n    await asyncForEach(\n      deactiveApps,\n      async (appInfo) =>\n        await deactive(appInfo, getPath(appInfo.basename, location.pathname)),\n    );\n  }\n\n  setRouterConfig({\n    current: {\n      path: getPath(RouterConfig.basename!),\n      fullPath: location.pathname,\n      matched: activeApps,\n      state: history.state,\n      query: parseQuery(location.search),\n    },\n  });\n\n  // Within the application routing jump, by collecting the routing function for processing.\n  // Filtering gar-router popstate hijacking of the router\n  // In the switch back and forth in the application is provided through routing push method would trigger application updates\n  // application will refresh when autoRefresh configuration to true\n  const curState = window.history.state || {};\n  if (\n    eventType !== 'popstate' &&\n    (curState[__GARFISH_ROUTER_UPDATE_FLAG__] || autoRefreshApp)\n  ) {\n    callCapturedEventListeners(eventType);\n  }\n\n  await asyncForEach(needToActive, async (appInfo) => {\n    // Function using matches character and routing using string matching characters\n    const appRootPath = getAppRootPath(appInfo);\n    await active(appInfo, appRootPath);\n  });\n\n  if (activeApps.length === 0 && notMatch) notMatch(location.pathname);\n\n  await toMiddleWare(to, from, afterEach!);\n};\n", "import { getPath, parseQuery } from './utils/urlUt';\nimport { createEvent } from './utils';\nimport {\n  RouterConfig,\n  __GARFISH_ROUTER_UPDATE_FLAG__,\n  __GARFISH_ROUTER_FLAG__,\n  __GARFISH_BEFORE_ROUTER_EVENT__,\n} from './config';\nimport CustomEvent from './utils/customEvent';\nimport { linkTo } from './linkTo';\n\nexport const normalAgent = () => {\n  // By identifying whether have finished listening, if finished listening, listening to the routing changes do not need to hijack the original event\n  // Support nested scene\n  const addRouterListener = function () {\n    window.addEventListener(__GARFISH_BEFORE_ROUTER_EVENT__, function (env) {\n      RouterConfig.routerChange && RouterConfig.routerChange(location.pathname);\n      linkTo((env as any).detail);\n    });\n  };\n\n  if (!window[__GARFISH_ROUTER_FLAG__]) {\n    // Listen for pushState and replaceState, call linkTo, processing, listen back\n    // Rewrite the history API method, triggering events in the call\n\n    const rewrite = function (type: keyof History) {\n      const hapi = history[type];\n      return function (this: History) {\n        const urlBefore = window.location.pathname + window.location.hash;\n        const stateBefore = history?.state;\n        const res = hapi.apply(this, arguments);\n        const urlAfter = window.location.pathname + window.location.hash;\n        const stateAfter = history?.state;\n\n        const e = createEvent(type);\n        (e as any).arguments = arguments;\n\n        if (\n          urlBefore !== urlAfter ||\n          JSON.stringify(stateBefore) !== JSON.stringify(stateAfter)\n        ) {\n          window.dispatchEvent(\n            new CustomEvent(__GARFISH_BEFORE_ROUTER_EVENT__, {\n              detail: {\n                toRouterInfo: {\n                  fullPath: urlAfter,\n                  query: parseQuery(location.search),\n                  path: getPath(RouterConfig.basename!, urlAfter),\n                  state: stateAfter,\n                },\n                fromRouterInfo: {\n                  fullPath: urlBefore,\n                  query: parseQuery(location.search),\n                  path: getPath(RouterConfig.basename!, urlBefore),\n                  state: stateBefore,\n                },\n                eventType: type,\n              },\n            }),\n          );\n        }\n        // window.dispatchEvent(e);\n        return res;\n      };\n    };\n\n    history.pushState = rewrite('pushState');\n    history.replaceState = rewrite('replaceState');\n\n    // Before the collection application sub routing, forward backward routing updates between child application\n    window.addEventListener(\n      'popstate',\n      function (event) {\n        // Stop trigger collection function, fire again match rendering\n        if (event && typeof event === 'object' && (event as any).garfish)\n          return;\n        if (history.state && typeof history.state === 'object')\n          delete history.state[__GARFISH_ROUTER_UPDATE_FLAG__];\n        window.dispatchEvent(\n          new CustomEvent(__GARFISH_BEFORE_ROUTER_EVENT__, {\n            detail: {\n              toRouterInfo: {\n                fullPath: location.pathname,\n                query: parseQuery(location.search),\n                path: getPath(RouterConfig.basename!),\n              },\n              fromRouterInfo: {\n                fullPath: RouterConfig.current!.fullPath,\n                path: getPath(\n                  RouterConfig.basename!,\n                  RouterConfig.current!.path,\n                ),\n                query: RouterConfig.current!.query,\n              },\n              eventType: 'popstate',\n            },\n          }),\n        );\n      },\n      false,\n    );\n\n    window[__GARFISH_ROUTER_FLAG__] = true;\n  }\n  addRouterListener();\n};\n\nexport const initRedirect = () => {\n  linkTo({\n    toRouterInfo: {\n      fullPath: location.pathname,\n      path: getPath(RouterConfig.basename!),\n      query: parseQuery(location.search),\n      state: history.state,\n    },\n    fromRouterInfo: {\n      fullPath: '/',\n      path: '/',\n      query: {},\n      state: {},\n    },\n    eventType: 'pushState',\n  });\n};\n\nexport const listen = () => {\n  normalAgent();\n  initRedirect();\n};\n", "import { interfaces } from '@garfish/core';\nimport { listen } from './agentRouter';\nimport {\n  setRouterConfig,\n  RouterConfig,\n  set as RouterSet,\n  Options,\n  RouterHook,\n  RouterChange,\n} from './config';\n\nimport { push, replace } from './utils/navEvent';\n\nexport { push, replace } from './utils/navEvent';\n\nexport const beforeEach = (hook: RouterHook) => {\n  RouterSet('beforeEach', hook);\n};\n\nexport const afterEach = (hook: RouterHook) => {\n  RouterSet('afterEach', hook);\n};\n\nexport const routerChange = (hook: RouterChange) => {\n  RouterSet('routerChange', hook);\n};\n\nexport const registerRouter = (Apps: Array<interfaces.AppInfo>) => {\n  const unregisterApps = Apps.filter(\n    (app) => !RouterConfig.apps.some((item) => app.name === item.name),\n  );\n  RouterSet('apps', RouterConfig.apps.concat(unregisterApps));\n};\n\n/**\n * 1.\u6CE8\u518C\u5B50\u5E94\u7528\n * 2.\u5BF9\u5E94\u5B50\u5E94\u7528\u6FC0\u6D3B\uFF0C\u89E6\u53D1\u6FC0\u6D3B\u56DE\u8C03\n * @param Options\n */\nexport const listenRouterAndReDirect = ({\n  apps,\n  basename = '/',\n  autoRefreshApp,\n  active,\n  deactive,\n  notMatch,\n  listening = true,\n}: Options) => {\n  // \u6CE8\u518C\u5B50\u5E94\u7528\u3001\u6CE8\u518C\u6FC0\u6D3B\u3001\u9500\u6BC1\u94A9\u5B50\n  registerRouter(apps);\n\n  // \u521D\u59CB\u5316\u4FE1\u606F\n  setRouterConfig({\n    basename,\n    autoRefreshApp,\n    // supportProxy: !!window.Proxy,\n    active,\n    deactive,\n    notMatch,\n    listening,\n  });\n\n  // \u5F00\u59CB\u76D1\u542C\u8DEF\u7531\u53D8\u5316\u89E6\u53D1\u3001\u5B50\u5E94\u7528\u66F4\u65B0\u3002\u91CD\u8F7D\u9ED8\u8BA4\u521D\u59CB\u5B50\u5E94\u7528\n  listen();\n};\n\nexport interface RouterInterface {\n  push: ({\n    path,\n    query,\n    basename,\n  }: {\n    path: string;\n    basename?: string;\n    query?: {\n      [key: string]: string;\n    };\n  }) => void;\n  replace: ({\n    path,\n    query,\n    basename,\n  }: {\n    path: string;\n    basename?: string;\n    query?: {\n      [key: string]: string;\n    };\n  }) => void;\n  beforeEach: (hook: RouterHook) => void;\n  afterEach: (hook: RouterHook) => void;\n  registerRouter: (\n    Apps: interfaces.AppInfo | Array<interfaces.AppInfo>,\n  ) => void;\n  routerChange: (hook: RouterChange) => void;\n  setRouterConfig: typeof setRouterConfig;\n  listenRouterAndReDirect: ({\n    apps,\n    basename,\n    autoRefreshApp,\n    active,\n    deactive,\n    notMatch,\n  }: Options) => void;\n  routerConfig: Options;\n}\n\nconst Router: RouterInterface = {\n  push,\n  replace,\n  beforeEach,\n  afterEach,\n  registerRouter,\n  routerChange,\n  listenRouterAndReDirect,\n  setRouterConfig,\n  routerConfig: RouterConfig,\n};\n\nexport { initRedirect } from './agentRouter';\n\n//eslint-disable-next-line\nexport default Router;\n"],
  "mappings": "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",
  "names": []
}
