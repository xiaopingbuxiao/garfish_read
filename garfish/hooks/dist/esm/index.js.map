{
  "version": 3,
  "sources": ["../../src/syncHook.ts", "../../src/asyncHook.ts", "../../src/syncWaterfallHook.ts", "../../src/asyncWaterfallHooks.ts", "../../src/pluginSystem.ts"],
  "sourcesContent": ["import { warn } from '@garfish/utils';\n\nexport type Callback<T, K> = (...args: ArgsType<T>) => K;\nexport type ArgsType<T> = T extends Array<any> ? T : Array<any>;\n\nexport class SyncHook<T, K> {\n  public type: string = '';\n  public listeners = new Set<Callback<T, K>>();\n\n  constructor(type?: string) {\n    if (type) this.type = type;\n  }\n\n  on(fn: Callback<T, K>) {\n    if (typeof fn === 'function') {\n      this.listeners.add(fn);\n    } else if ((typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false)) {\n      warn('Invalid parameter in \"Hook\".');\n    }\n  }\n\n  once(fn: Callback<T, K>) {\n    const self = this;\n    this.on(function wrapper(...args: Array<any>) {\n      self.remove(wrapper);\n      return fn.apply(null, args);\n    });\n  }\n\n  emit(...data: ArgsType<T>) {\n    if (this.listeners.size > 0) {\n      this.listeners.forEach((fn) => fn.apply(null, data));\n    }\n  }\n\n  remove(fn: Callback<T, K>) {\n    return this.listeners.delete(fn);\n  }\n\n  removeAll() {\n    this.listeners.clear();\n  }\n}\n", "import { ArgsType, SyncHook } from './syncHook';\n\ntype CallbackReturnType = void | false | Promise<void | false>;\n\nexport class AsyncHook<\n  T,\n  ExternalEmitReturnType = CallbackReturnType,\n> extends SyncHook<T, CallbackReturnType | Promise<ExternalEmitReturnType>> {\n  emit(...data: ArgsType<T>): Promise<void | false | ExternalEmitReturnType> {\n    let result;\n    const ls = Array.from(this.listeners);\n    if (ls.length > 0) {\n      let i = 0;\n      const call = (prev?: any) => {\n        if (prev === false) {\n          return false; // Abort process\n        } else if (i < ls.length) {\n          return Promise.resolve(ls[i++].apply(null, data)).then(call);\n        } else {\n          return prev;\n        }\n      };\n      result = call();\n    }\n    return Promise.resolve(result);\n  }\n}\n", "import { warn, error, isObject } from '@garfish/utils';\nimport { SyncHook } from './syncHook';\n\nexport function checkReturnData(originData, returnData) {\n  if (!isObject(returnData)) return false;\n  if (originData !== returnData) {\n    for (const key in originData) {\n      if (!(key in returnData)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nexport class SyncWaterfallHook<T extends Record<string, any>> extends SyncHook<\n  [T],\n  T\n> {\n  public onerror: (errMsg: string | Error) => void = error;\n\n  constructor(type: string) {\n    super();\n    this.type = type;\n  }\n\n  emit(data: T) {\n    if (!isObject(data)) {\n      error(`\"${this.type}\" hook response data must be an object.`);\n    }\n    for (const fn of this.listeners) {\n      try {\n        const tempData = fn(data);\n        if (checkReturnData(data, tempData)) {\n          data = tempData;\n        } else {\n          this.onerror(\n            `The \"${this.type}\" type has a plugin return value error.`,\n          );\n          break;\n        }\n      } catch (e) {\n        (typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false) && warn(e);\n        this.onerror(e);\n      }\n    }\n    return data;\n  }\n}\n", "import { warn, error, isObject } from '@garfish/utils';\nimport { SyncHook } from './syncHook';\nimport { checkReturnData } from './syncWaterfallHook';\n\ntype CallbackReturnType<T> = T | false | Promise<T | false>;\n\nexport class AsyncWaterfallHook<T extends Record<string, any>> extends SyncHook<\n  [T],\n  CallbackReturnType<T>\n> {\n  public onerror: (errMsg: string | Error) => void = error;\n\n  constructor(type: string) {\n    super();\n    this.type = type;\n  }\n\n  emit(data: T): Promise<T | false> {\n    if (!isObject(data)) {\n      error(`\"${this.type}\" hook response data must be an object.`);\n    }\n    const ls = Array.from(this.listeners);\n\n    if (ls.length > 0) {\n      let i = 0;\n      const processError = (e) => {\n        (typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false) && warn(e);\n        this.onerror(e);\n        return data;\n      };\n\n      const call = (prevData: T | false) => {\n        if (prevData === false) {\n          return false;\n        } else if (checkReturnData(data, prevData)) {\n          data = prevData as T;\n          if (i < ls.length) {\n            try {\n              return Promise.resolve(ls[i++](data)).then(call, processError);\n            } catch (e) {\n              return processError(e);\n            }\n          }\n        } else {\n          this.onerror(\n            `The \"${this.type}\" type has a plugin return value error.`,\n          );\n        }\n        return data;\n      };\n      return Promise.resolve(call(data));\n    }\n    return Promise.resolve(data);\n  }\n}\n", "import { warn, assert, isPlainObject } from '@garfish/utils';\n\nexport type Plugin<T extends Record<string, any>> = {\n  [k in keyof T]?: Parameters<T[k]['on']>[0];\n} & {\n  name: string;\n  version?: string;\n};\n\nexport class PluginSystem<T extends Record<string, any>> {\n  lifecycle: T;\n  lifecycleKeys: Array<keyof T>;\n  registerPlugins: Record<string, Plugin<T>> = {};\n\n  constructor(lifecycle: T) {\n    this.lifecycle = lifecycle;\n    this.lifecycleKeys = Object.keys(lifecycle);\n  }\n\n  usePlugin(plugin: Plugin<T>) {\n    assert(isPlainObject(plugin), 'Invalid plugin configuration.');\n    // Plugin name is required and unique\n    const pluginName = plugin.name;\n    assert(pluginName, 'Plugin must provide a name.');\n\n    if (!this.registerPlugins[pluginName]) {\n      this.registerPlugins[pluginName] = plugin;\n\n      for (const key in this.lifecycle) {\n        const pluginLife = plugin[key as string];\n        if (pluginLife) {\n          // Differentiate different types of hooks and adopt different registration strategies\n          this.lifecycle[key].on(pluginLife);\n        }\n      }\n    } else {\n      warn(`Repeat to register plugin hooks \"${pluginName}\".`);\n    }\n  }\n\n  removePlugin(pluginName: string) {\n    assert(pluginName, 'Must provide a name.');\n    const plugin = this.registerPlugins[pluginName];\n    assert(plugin, `plugin \"${pluginName}\" is not registered.`);\n\n    for (const key in plugin) {\n      if (key === 'name') continue;\n      this.lifecycle[key].remove(plugin[key as string]);\n    }\n  }\n\n  inherit<T extends PluginSystem<any>>({ lifecycle, registerPlugins }: T) {\n    for (const hookName in lifecycle) {\n      assert(\n        !this.lifecycle[hookName],\n        `\"${hookName as string}\" hook has conflict and cannot be inherited.`,\n      );\n      (this.lifecycle as any)[hookName] = lifecycle[hookName];\n    }\n\n    for (const pluginName in registerPlugins) {\n      assert(\n        !this.registerPlugins[pluginName],\n        `\"${pluginName}\" plugin has conflict and cannot be inherited.`,\n      );\n      this.usePlugin(registerPlugins[pluginName]);\n    }\n    return this as typeof this & T;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
