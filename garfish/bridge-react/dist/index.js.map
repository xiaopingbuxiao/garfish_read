{
  "version": 3,
  "sources": ["../src/index.ts", "../src/reactBridge.ts"],
  "sourcesContent": ["export { reactBridge } from './reactBridge';\nexport type { PropsInfo } from './types';\n", "// The logic of reactBridge is referenced from single-spa typography\n// Because the Garfish lifecycle does not agree with that of single-spa  part logical coupling in the framework\n// https://github.com/single-spa/single-spa-react/blob/main/src/single-spa-react.js\n\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport type { UserOptions, PropsInfo } from './types';\nimport { warn } from '@garfish/utils';\n\ntype typeReact = typeof React | undefined;\ntype Options = UserOptions<typeof React, typeof ReactDOM, any, React.ReactNode>;\n\nconst defaultOpts = {\n  // required - one or the other or both\n  rootComponent: undefined,\n  loadRootComponent: undefined,\n\n  // optional opts\n  renderType: undefined,\n  errorBoundary: undefined,\n  el: undefined,\n  canUpdate: true, // by default, allow parcels created with garfish-react-bridge to be updated\n  suppressComponentDidCatchWarning: false,\n  domElements: {},\n  renderResults: {},\n  updateResolves: {},\n};\n\ndeclare const __GARFISH_EXPORTS__: {\n  provider: Object;\n};\n\ndeclare global {\n  interface Window {\n    __GARFISH__: boolean;\n  }\n}\n\nexport function reactBridge(this: any, userOptions: Options) {\n  if (typeof userOptions !== 'object') {\n    throw new Error('garfish-react-bridge requires a configuration object');\n  }\n\n  const opts: Options = {\n    ...defaultOpts,\n    ...userOptions,\n  };\n\n  opts.React = opts.React || React;\n  opts.ReactDOM = opts.ReactDOM || ReactDOM;\n\n  if (!opts.rootComponent && !opts.loadRootComponent) {\n    throw new Error(\n      'garfish-react-bridge must be passed opts.rootComponent or opts.loadRootComponent',\n    );\n  }\n\n  if (opts.rootComponent && opts.loadRootComponent) {\n    warn(\n      'garfish-react-bridge: `RootComponent` will be ignored for the reason you have passed both `rootComponent` and `loadRootComponent`.',\n    );\n  }\n\n  if (opts.errorBoundary && typeof opts.errorBoundary !== 'function') {\n    throw Error(\n      'The errorBoundary opt for garfish-react-bridge must either be omitted or be a function that returns React elements',\n    );\n  }\n  if (!checkReactVersion(opts.React)) {\n    throw Error(\n      'Please make sure than the react version is higher than or equal to v16 and lower than v18.',\n    );\n  }\n\n  const providerLifeCycle = {\n    render: (appInfo) => mount.call(this, opts, appInfo),\n    destroy: (appInfo) => unmount.call(this, opts, appInfo),\n    // update: (appInfo) => opts.canUpdate && update.call(this, opts, appInfo),\n  };\n\n  const provider = async function (this: any, appInfo, props) {\n    await bootstrap.call(this, opts, appInfo, props);\n    return providerLifeCycle;\n  };\n\n  if (\n    window.__GARFISH__ &&\n    typeof __GARFISH_EXPORTS__ === 'object' &&\n    __GARFISH_EXPORTS__\n  ) {\n    __GARFISH_EXPORTS__.provider = provider;\n  }\n  return provider;\n}\n\nfunction bootstrap(opts: Options, appInfo: PropsInfo, props) {\n  if (opts.loadRootComponent) {\n    // They passed a promise that resolves with the react component. Wait for it to resolve before mounting\n    try {\n      return opts\n        .loadRootComponent({\n          ...appInfo,\n          props,\n        })\n        .then((resolvedComponent) => {\n          opts.rootComponent = resolvedComponent;\n        });\n    } catch (error) {\n      console.error('error log by garfish: loadRootComponent error:', error);\n      throw new Error(error);\n    }\n  } else {\n    // This is a class or stateless function component\n    return Promise.resolve();\n  }\n}\n\nfunction mount(opts: Options, appInfo: PropsInfo) {\n  if (\n    !opts.suppressComponentDidCatchWarning &&\n    checkReactVersion(opts.React) &&\n    !opts.errorBoundary\n  ) {\n    if (opts.rootComponent && !opts.rootComponent.prototype) {\n      warn(\n        `garfish-react-bridge: ${appInfo.appName}'s rootComponent does not implement an error boundary.  If using a functional component, consider providing an opts.errorBoundary to reactBridge(opts).`,\n      );\n    } else if (\n      opts.rootComponent &&\n      !opts.rootComponent.prototype.componentDidCatch\n    ) {\n      warn(\n        `garfish-react-bridge: ${appInfo.appName}'s rootComponent should implement componentDidCatch to avoid accidentally unmounting the entire garfish application.`,\n      );\n    }\n  }\n\n  const elementToRender = getElementToRender(opts, appInfo);\n  const domElement = chooseDomElementGetter(opts, appInfo);\n  const renderResult = reactDomRender({\n    elementToRender,\n    domElement,\n    opts,\n  });\n  opts.domElements ? (opts.domElements[appInfo.appName] = domElement) : '';\n  // opts.renderResults[appInfo.appName] = renderResult;\n}\n\nfunction unmount(opts: Options, appInfo: PropsInfo) {\n  if (opts.domElements) {\n    opts.ReactDOM &&\n      opts.ReactDOM.unmountComponentAtNode(opts.domElements[appInfo.appName]);\n    delete opts.domElements[appInfo.appName];\n    // delete opts.renderResults[appInfo.appName];\n  }\n}\n\n// function update(opts, appInfo: PropsInfo) {\n//   return new Promise((resolve) => {\n//     if (!opts.updateResolves[appInfo.appName]) {\n//       opts.updateResolves[appInfo.appName] = [];\n//     }\n\n//     opts.updateResolves[appInfo.appName].push(resolve);\n\n//     const elementToRender = getElementToRender(opts, appInfo);\n//     const domElement = chooseDomElementGetter(opts, appInfo);\n\n//     // This is the old way to update a react application - just call render() again\n//     opts.ReactDOM.render(elementToRender, domElement);\n//   });\n// }\n\nfunction checkReactVersion(React: typeReact) {\n  if (\n    React &&\n    typeof React.version === 'string' &&\n    React.version.indexOf('.') >= 0\n  ) {\n    const majorVersionString = React.version.split('.')[0];\n    try {\n      return (\n        Number(majorVersionString) >= 16 && Number(majorVersionString) < 18\n      );\n    } catch (err) {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n\nfunction reactDomRender({ opts, elementToRender, domElement }) {\n  const renderType =\n    typeof opts.renderType === 'function' ? opts.renderType() : opts.renderType;\n\n  if (renderType === 'hydrate') {\n    opts.ReactDOM.hydrate(elementToRender, domElement);\n  } else {\n    // default to this if 'renderType' is null or doesn't match the other options\n    opts.ReactDOM.render(elementToRender, domElement);\n  }\n  // The reactDomRender function should return a react root, but ReactDOM.hydrate() and ReactDOM.render()\n  // do not return a react root. So instead, we return null which indicates that there is no react root\n  // that can be used for updates or unmounting\n  return null;\n}\n\nfunction getElementToRender(opts: Options, appInfo: PropsInfo) {\n  if (opts.React) {\n    const rootComponentElement = opts.React.createElement(\n      opts.rootComponent,\n      appInfo,\n    );\n    let elementToRender = rootComponentElement;\n\n    if (opts.errorBoundary) {\n      elementToRender = opts.React.createElement(\n        createErrorBoundary(opts) as any,\n        appInfo,\n        elementToRender,\n      );\n    }\n    return rootComponentElement;\n  }\n}\n\nfunction createErrorBoundary(opts: Options) {\n  // Avoiding babel output for class syntax and super()\n  // to avoid bloat\n  function GarfishSubAppReactErrorBoundary(this: any, props) {\n    // super\n    opts.React && opts.React.Component.apply(this, arguments);\n\n    this.state = {\n      caughtError: null,\n      caughtErrorInfo: null,\n    };\n\n    (\n      GarfishSubAppReactErrorBoundary as any\n    ).displayName = `ReactBridgeReactErrorBoundary(${props.name})`;\n  }\n\n  GarfishSubAppReactErrorBoundary.prototype =\n    opts.React && Object.create(opts.React.Component.prototype);\n\n  GarfishSubAppReactErrorBoundary.prototype.render = function () {\n    if (this.state.caughtError) {\n      const errorBoundary = opts.errorBoundary;\n      return errorBoundary && errorBoundary(this.state.caughtError, this.props);\n    } else {\n      return this.props.children;\n    }\n  };\n\n  GarfishSubAppReactErrorBoundary.prototype.componentDidCatch = function (\n    err,\n    info,\n  ) {\n    this.setState({\n      caughtError: err,\n      caughtErrorInfo: info,\n    });\n  };\n\n  return GarfishSubAppReactErrorBoundary;\n}\n\nfunction chooseDomElementGetter(opts: Options, appInfo: PropsInfo) {\n  const { dom: container } = appInfo;\n  let el;\n  if (typeof opts.el === 'string') {\n    el = container.querySelector(opts.el);\n  } else {\n    el = container;\n  }\n\n  if (!(el instanceof HTMLElement)) {\n    throw Error(\n      `react bridge's dom-element-getter-helpers: el is an invalid dom element for application'${\n        appInfo.appName\n      }'. Expected HTMLElement, received ${typeof el}`,\n    );\n  }\n  return el;\n}\n"],
  "mappings": "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",
  "names": []
}
