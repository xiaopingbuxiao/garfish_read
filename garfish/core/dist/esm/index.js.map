{
  "version": 3,
  "sources": ["../../src/garfish.ts", "../../src/config.ts", "../../src/module/app.ts", "../../src/lifecycle.ts", "../../src/module/esModule.ts", "../../src/module/resource.ts", "../../src/plugins/fixHMR.ts", "../../src/plugins/lifecycle.ts", "../../src/plugins/preload.ts", "../../src/plugins/performance/subAppObserver.ts", "../../src/plugins/performance/index.ts", "../../src/plugins/logger.ts"],
  "sourcesContent": ["import { Loader } from '@garfish/loader';\nimport { EventEmitter2 } from 'eventemitter2';\nimport { warn, assert, isPlainObject, __GARFISH_FLAG__ } from '@garfish/utils';\nimport {\n  SyncHook,\n  AsyncHook,\n  SyncWaterfallHook,\n  AsyncWaterfallHook,\n  PluginSystem,\n} from '@garfish/hooks';\nimport {\n  deepMergeConfig,\n  generateAppOptions,\n  createDefaultOptions,\n} from './config';\nimport { App } from './module/app';\nimport { interfaces } from './interface';\nimport { globalLifecycle } from './lifecycle';\nimport { processAppResources } from './module/resource';\nimport { GarfishHMRPlugin } from './plugins/fixHMR';\nimport { GarfishOptionsLife } from './plugins/lifecycle';\nimport { GarfishPreloadPlugin } from './plugins/preload';\nimport { GarfishPerformance } from './plugins/performance';\nimport { GarfishLogger } from './plugins/logger';\n\nconst DEFAULT_PROPS = new WeakMap();\nconst HOOKS_API = {\n  SyncHook,\n  AsyncHook,\n  SyncWaterfallHook,\n  AsyncWaterfallHook,\n};\n\nexport class Garfish extends EventEmitter2 {\n  public running = false;\n  public version = '1.12.0';\n  public flag = __GARFISH_FLAG__; // A unique identifier\n  public loader = new Loader();\n  public hooks = globalLifecycle();\n  public channel = new EventEmitter2();\n  public options = createDefaultOptions();\n  public externals: Record<string, any> = {};\n  public activeApps: Array<interfaces.App> = [];\n  public plugins: interfaces.Plugins = {} as any;\n  public cacheApps: Record<string, interfaces.App> = {};\n  public appInfos: Record<string, interfaces.AppInfo> = {};\n\n  private loading: Record<string, Promise<any>> = {};\n\n  get props(): Record<string, any> {\n    return (this.options && this.options.props) || DEFAULT_PROPS.get(this);\n  }\n\n  constructor(options: interfaces.Options) {\n    super();\n    this.setOptions(options);\n    DEFAULT_PROPS.set(this, {});\n    this.options.plugins?.forEach((plugin) => this.usePlugin(plugin));\n    this.usePlugin(GarfishHMRPlugin());\n    this.usePlugin(GarfishPerformance());\n    this.usePlugin(GarfishPreloadPlugin());\n    this.usePlugin(GarfishLogger());\n  }\n\n  setOptions(options: Partial<interfaces.Options>) {\n    assert(!this.running, 'Garfish is running, can`t set options');\n    if (isPlainObject(options)) {\n      this.options = deepMergeConfig(this.options, options);\n    }\n    return this;\n  }\n\n  createPluginSystem<T extends (api: typeof HOOKS_API) => any>(callback: T) {\n    const hooks = callback(HOOKS_API);\n    return new PluginSystem<ReturnType<T>>(hooks);\n  }\n\n  usePlugin(\n    plugin: (context: Garfish) => interfaces.Plugin,\n    ...args: Array<any>\n  ) {\n    assert(!this.running, 'Cannot register plugin after Garfish is started.');\n    assert(typeof plugin === 'function', 'Plugin must be a function.');\n    args.unshift(this);\n    const pluginConfig = plugin.apply(null, args) as interfaces.Plugin;\n    assert(pluginConfig.name, 'The plugin must have a name.');\n\n    if (!this.plugins[pluginConfig.name]) {\n      this.plugins[pluginConfig.name] = pluginConfig;\n      // Register hooks, Compatible with the old api\n      this.hooks.usePlugin(pluginConfig);\n    } else if ((typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false)) {\n      warn('Please do not register the plugin repeatedly.');\n    }\n    return this;\n  }\n\n  run(options: interfaces.Options = {}) {\n    if (this.running) {\n      if ((typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false)) {\n        warn('Garfish is already running now, Cannot run Garfish repeatedly.');\n      }\n      return this;\n    }\n\n    this.setOptions(options);\n    // Register plugins\n    options.plugins?.forEach((plugin) => this.usePlugin(plugin));\n    // Put the lifecycle plugin at the end, so that you can get the changes of other plugins\n    this.usePlugin(GarfishOptionsLife(this.options, 'global-lifecycle'));\n\n    // Emit hooks and register apps\n    this.hooks.lifecycle.beforeBootstrap.emit(this.options);\n    this.registerApp(this.options.apps || []);\n    this.running = true;\n    this.hooks.lifecycle.bootstrap.emit(this.options);\n    return this;\n  }\n\n  registerApp(list: interfaces.AppInfo | Array<interfaces.AppInfo>) {\n    const currentAdds = {};\n    this.hooks.lifecycle.beforeRegisterApp.emit(list);\n    if (!Array.isArray(list)) list = [list];\n\n    for (const appInfo of list) {\n      assert(appInfo.name, 'Miss app.name.');\n      if (!this.appInfos[appInfo.name]) {\n        assert(\n          appInfo.entry,\n          `${appInfo.name} application entry is not url: ${appInfo.entry}`,\n        );\n        currentAdds[appInfo.name] = appInfo;\n        this.appInfos[appInfo.name] = appInfo;\n      } else if ((typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false)) {\n        warn(`The \"${appInfo.name}\" app is already registered.`);\n      }\n    }\n    this.hooks.lifecycle.registerApp.emit(currentAdds);\n    return this;\n  }\n\n  setExternal(nameOrExtObj: string | Record<string, any>, value?: any) {\n    assert(nameOrExtObj, 'Invalid parameter.');\n    if (typeof nameOrExtObj === 'object') {\n      for (const key in nameOrExtObj) {\n        if ((typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false)) {\n          this.externals[key] &&\n            warn(`The \"${key}\" will be overwritten in external.`);\n        }\n        this.externals[key] = nameOrExtObj[key];\n      }\n    } else {\n      this.externals[nameOrExtObj] = value;\n    }\n    return this;\n  }\n\n  loadApp(\n    appName: string,\n    options?: Partial<Omit<interfaces.AppInfo, 'name'>>,\n  ): Promise<interfaces.App | null> {\n    assert(appName, 'Miss appName.');\n\n    let appInfo = generateAppOptions(appName, this, options);\n\n    const asyncLoadProcess = async () => {\n      // Return not undefined type data directly to end loading\n      const stop = await this.hooks.lifecycle.beforeLoad.emit(appInfo);\n\n      if (stop === false) {\n        warn(`Load ${appName} application is terminated by beforeLoad.`);\n        return null;\n      }\n\n      //merge configs again after beforeLoad for the reason of app may be re-registered during beforeLoad resulting in an incorrect information\n      appInfo = generateAppOptions(appName, this, options);\n\n      assert(\n        appInfo.entry,\n        `Can't load unexpected child app \"${appName}\", ` +\n          'Please provide the entry parameters or registered in advance of the app.',\n      );\n\n      // Existing cache caching logic\n      let appInstance: interfaces.App | null = null;\n      const cacheApp = this.cacheApps[appName];\n\n      if (appInfo.cache && cacheApp) {\n        appInstance = cacheApp;\n      } else {\n        try {\n          const [manager, resources, isHtmlMode] = await processAppResources(\n            this.loader,\n            appInfo,\n          );\n\n          appInstance = new App(\n            this,\n            appInfo,\n            manager,\n            resources,\n            isHtmlMode,\n            appInfo.customLoader,\n          );\n\n          // The registration hook will automatically remove the duplication\n          for (const key in this.plugins) {\n            appInstance.hooks.usePlugin(this.plugins[key]);\n          }\n          if (appInfo.cache) {\n            this.cacheApps[appName] = appInstance;\n          }\n        } catch (e) {\n          (typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false) && warn(e);\n          this.hooks.lifecycle.errorLoadApp.emit(e, appInfo);\n        }\n      }\n\n      await this.hooks.lifecycle.afterLoad.emit(appInfo, appInstance);\n      return appInstance;\n    };\n\n    if (!this.loading[appName]) {\n      this.loading[appName] = asyncLoadProcess().finally(() => {\n        delete this.loading[appName];\n      });\n    }\n    return this.loading[appName];\n  }\n}\n", "import {\n  error,\n  isObject,\n  deepMerge,\n  filterUndefinedVal,\n  assert,\n} from '@garfish/utils';\nimport { AppInfo } from './module/app';\nimport { interfaces } from './interface';\n\n// filter unless global config\nconst filterAppConfigKeys: Record<\n  Exclude<keyof interfaces.Options, keyof AppInfo>,\n  true\n> = {\n  beforeBootstrap: true,\n  bootstrap: true,\n  beforeRegisterApp: true,\n  registerApp: true,\n  beforeLoad: true,\n  afterLoad: true,\n  errorLoadApp: true,\n  appID: true,\n  apps: true,\n  disableStatistics: true,\n  disablePreloadApp: true,\n  plugins: true,\n  autoRefreshApp: true,\n  onNotMatchRouter: true,\n  loader: true,\n};\n\n// `props` may be responsive data\nexport const deepMergeConfig = <\n  T extends { props?: Record<string, any> },\n  U extends { props?: Record<string, any> },\n>(\n  globalConfig: T,\n  localConfig: U,\n) => {\n  const props = {\n    ...(globalConfig.props || {}),\n    ...(localConfig.props || {}),\n  };\n\n  const result = deepMerge(\n    filterUndefinedVal(globalConfig),\n    filterUndefinedVal(localConfig),\n  );\n  result.props = props;\n  return result;\n};\n\nexport const getAppConfig = (\n  globalConfig: interfaces.Options,\n  localConfig: AppInfo,\n): AppInfo => {\n  const mergeResult = deepMergeConfig(globalConfig, localConfig);\n\n  Object.keys(mergeResult).forEach((key: keyof interfaces.Config) => {\n    if (filterAppConfigKeys[key]) {\n      delete mergeResult[key];\n    }\n  });\n\n  return mergeResult;\n};\n\nexport const generateAppOptions = (\n  appName: string,\n  garfish: interfaces.Garfish,\n  options?: Partial<Omit<AppInfo, 'name'>>,\n): AppInfo => {\n  let appInfo: AppInfo = garfish.appInfos[appName] || { name: appName };\n\n  // Merge register appInfo config and loadApp config\n  appInfo = getAppConfig(garfish.options, {\n    ...appInfo,\n    ...options,\n    props: {\n      ...(appInfo.props || {}),\n      ...(options?.props || {}),\n    },\n  });\n\n  return appInfo;\n};\n\n// Each main application needs to generate a new configuration\nexport const createDefaultOptions = () => {\n  const config: interfaces.Options = {\n    // global config\n    appID: '',\n    apps: [],\n    autoRefreshApp: true,\n    disableStatistics: false,\n    disablePreloadApp: false,\n    // app config\n    basename: '/',\n    props: {},\n    // Use an empty div by default\n    domGetter: () => document.createElement('div'),\n    sandbox: {\n      snapshot: false,\n      fixBaseUrl: false,\n      disableWith: false,\n      strictIsolation: false,\n    },\n    // global hooks\n    beforeLoad: () => {},\n    afterLoad: () => {},\n    errorLoadApp: (e) => error(e),\n    // Router\n    onNotMatchRouter: () => {},\n    // app hooks\n    // Code eval hooks\n    beforeEval: () => {},\n    afterEval: () => {},\n    // App mount hooks\n    beforeMount: () => {},\n    afterMount: () => {},\n    beforeUnmount: () => {},\n    afterUnmount: () => {},\n    // Error hooks\n    errorMountApp: (e) => error(e),\n    errorUnmountApp: (e) => error(e),\n    customLoader: undefined, // deprecated\n  };\n\n  return config;\n};\n", "import { StyleManager, TemplateManager } from '@garfish/loader';\nimport {\n  Text,\n  Node,\n  warn,\n  assert,\n  hasOwn,\n  remove,\n  Queue,\n  coreLog,\n  isJsType,\n  isObject,\n  isPromise,\n  isGarfishConfigType,\n  toBoolean,\n  findTarget,\n  evalWithEnv,\n  transformUrl,\n  __MockBody__,\n  __MockHead__,\n  getRenderNode,\n  sourceListTags,\n  createAppContainer,\n  setDocCurrentScript,\n} from '@garfish/utils';\nimport { Garfish } from '../garfish';\nimport { interfaces } from '../interface';\nimport { appLifecycle } from '../lifecycle';\nimport { ESModuleLoader } from './esModule';\nimport { SubAppObserver } from '../plugins/performance/subAppObserver';\n\nexport type CustomerLoader = (\n  provider: interfaces.Provider,\n  appInfo: interfaces.AppInfo,\n  path?: string,\n) => Promise<interfaces.LoaderResult | void> | interfaces.LoaderResult | void;\n\nexport type AppInfo = interfaces.AppInfo & {\n  appId?: number;\n};\n\nexport interface ExecScriptOptions {\n  node?: Node;\n  async?: boolean;\n  noEntry?: boolean;\n  isInline?: boolean;\n  isModule?: boolean;\n}\n\nlet appId = 0;\nconst __GARFISH_GLOBAL_ENV__ = '__GARFISH_GLOBAL_ENV__';\nexport const __GARFISH_EXPORTS__ = '__GARFISH_EXPORTS__';\n\n// Have the ability to App instance\n// 1. Provide static resource, the structure of the HTML, CSS, js.\n// 2. Can be extracted in the js CJS through scope __GARFISH_EXPORTS__ namespace or get child application provider is deduced.\n// 3. Through execCode incoming environment variables such as CJS specification of the module, the require, exports to realize external sharing\n// 4. Trigger rendering\uFF1AApplication related nodes placed in the document flow, which in turn perform application scripts, final render function,\n//    perform the son application provides complete application independent runtime execution.\n// 5. Trigger the destruction: Perform the destroy function of child application, and applies the child node is removed from the document flow.\nexport class App {\n  public appId = appId++;\n  public scriptCount = 0;\n  public display = false;\n  public mounted = false;\n  public strictIsolation = false;\n  public esmQueue = new Queue();\n  public esModuleLoader = new ESModuleLoader(this);\n  public name: string;\n  public isHtmlMode: boolean;\n  public global: any = window;\n  public appContainer: HTMLElement;\n  public cjsModules: Record<string, any>;\n  public htmlNode: HTMLElement | ShadowRoot;\n  public customExports: Record<string, any> = {}; // If you don't want to use the CJS export, can use this\n  public sourceList: Array<{ tagName: string; url: string }> = [];\n  public sourceListMap: Map<string, { tagName: string; url: string }> = new Map();\n  public appInfo: AppInfo;\n  public context: Garfish;\n  public hooks: interfaces.AppHooks;\n  public provider?: interfaces.Provider;\n  public entryManager: TemplateManager;\n  public appPerformance: SubAppObserver;\n  public customLoader?: CustomerLoader;\n  public childGarfishConfig: interfaces.ChildGarfishConfig = {};\n  private active = false;\n  public mounting = false;\n  private unmounting = false;\n  private resources: interfaces.ResourceModules;\n  // Environment variables injected by garfish for linkage with child applications\n  private globalEnvVariables: Record<string, any>;\n\n  constructor(\n    context: Garfish,\n    appInfo: AppInfo,\n    entryManager: TemplateManager,\n    resources: interfaces.ResourceModules,\n    isHtmlMode: boolean,\n    customLoader?: CustomerLoader,\n  ) {\n    this.context = context;\n    this.appInfo = appInfo;\n    this.name = appInfo.name;\n    this.resources = resources;\n    this.isHtmlMode = isHtmlMode;\n    this.entryManager = entryManager;\n\n    // `appInfo` is completely independent and can be associated with `appId`\n    this.appInfo.appId = this.appId;\n\n    // Garfish environment variables\n    this.globalEnvVariables = {\n      currentApp: this,\n      loader: context.loader,\n      externals: context.externals,\n      remoteModulesCode: resources.modules,\n    };\n    this.cjsModules = {\n      exports: {},\n      module: null,\n      require: (key: string) => {\n        const pkg = this.global[key] || context.externals[key] || window[key];\n        if (!pkg) {\n          warn(`Package \"${key}\" is not found`);\n        }\n        return pkg;\n      },\n    };\n    this.cjsModules.module = this.cjsModules;\n    this.customLoader = customLoader;\n\n    // Register hooks\n    this.hooks = appLifecycle();\n    this.hooks.usePlugin({\n      ...appInfo,\n      name: `${appInfo.name}-lifecycle`,\n    });\n\n    // Save all the resources to address\n    const nodes = entryManager.getNodesByTagName(...sourceListTags);\n    for (const key in nodes) {\n      nodes[key].forEach((node) => {\n        const url =\n          entryManager.findAttributeValue(node, 'href') ||\n          entryManager.findAttributeValue(node, 'src');\n        if (url) {\n          this.addSourceList({\n            tagName: node.tagName,\n            url: entryManager.url ? transformUrl(entryManager.url, url) : url,\n          });\n        }\n        if (isGarfishConfigType({ type: entryManager.findAttributeValue(node, 'type') })) {\n          // garfish config script founded\n          // parse it\n          this.childGarfishConfig = JSON.parse((node.children?.[0] as Text)?.content);\n        }\n      });\n    }\n    this.appInfo.entry && this.addSourceList({ tagName: 'html', url: this.appInfo.entry })\n  }\n\n  get rootElement() {\n    return findTarget(this.htmlNode, [`div[${__MockBody__}]`, 'body']);\n  }\n\n  get getSourceList () {\n    return this.sourceList;\n  }\n\n  addSourceList(sourceInfo: Array<{ tagName: string; url: string }> | { tagName: string; url: string }){\n    if (this.appInfo.disableSourceListCollect) return;\n    if (Array.isArray(sourceInfo)){\n      let nSourceList = sourceInfo.filter(item => {\n        if (!this.sourceListMap.has(item.url) && item.url.startsWith('http')) {\n          this.sourceListMap.set(item.url, item);\n          return true;\n        }\n        return false;\n      });\n      this.sourceList = this.sourceList.concat(nSourceList);\n    } else {\n      if (!this.sourceListMap.get(sourceInfo.url) && sourceInfo.url.startsWith('http')){\n        this.sourceList.push(sourceInfo);\n        this.sourceListMap.set(sourceInfo.url, sourceInfo);\n      }\n    }\n  }\n  \n  getProvider() {\n    return this.provider\n      ? Promise.resolve(this.provider)\n      : this.checkAndGetProvider();\n  }\n\n  isNoEntryScript(url = '') {\n    return this.childGarfishConfig.sandbox?.noEntryScripts?.some(item => url.indexOf(item) > -1);\n  }\n\n  execScript(\n    code: string,\n    env: Record<string, any>,\n    url?: string,\n    options?: interfaces.ExecScriptOptions,\n  ) {\n    env = {\n      ...this.getExecScriptEnv(options?.noEntry),\n      ...(env || {}),\n    };\n\n    this.scriptCount++;\n\n    const args = [this.appInfo, code, env, url, options] as const;\n    this.hooks.lifecycle.beforeEval.emit(...args);\n    try {\n      this.runCode(code, env, url, options);\n    } catch (err) {\n      this.hooks.lifecycle.errorExecCode.emit(err, ...args);\n      throw err;\n    }\n\n    this.hooks.lifecycle.afterEval.emit(...args);\n  }\n\n  // `vm sandbox` can override this method\n  runCode(\n    code: string,\n    env: Record<string, any>,\n    url?: string,\n    options?: interfaces.ExecScriptOptions,\n  ) {\n    // If the node is an es module, use native esmModule\n    if (options && options.isModule) {\n      this.esmQueue.add(async (next) => {\n        await this.esModuleLoader.load(code, {\n          // rebuild full env\n          ...this.getExecScriptEnv(),\n          // this 'env' may lost commonjs data\n          ...env,\n        }, url, options);\n        next();\n      });\n    } else {\n      const revertCurrentScript = setDocCurrentScript(\n        this.global.document,\n        code,\n        true,\n        url,\n        options?.async,\n        options?.originScript,\n      );\n      code += url ? `\\n//# sourceURL=${url}\\n` : '';\n      if (!hasOwn(env, 'window')) {\n        env = {\n          ...env,\n          window: this.global,\n        };\n      }\n      evalWithEnv(`;${code}`, env, this.global);\n      Promise.resolve().then(revertCurrentScript);\n    }\n  }\n\n  async show() {\n    this.active = true;\n    const { display, mounted, provider } = this;\n    if (display) return false;\n    if (!mounted) {\n      (typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false) && warn('Need to call the \"app.mount()\" method first.');\n      return false;\n    }\n    this.hooks.lifecycle.beforeMount.emit(this.appInfo, this, true);\n    this.context.activeApps.push(this);\n\n    await this.addContainer();\n    this.callRender(provider, false);\n    this.display = true;\n    this.hooks.lifecycle.afterMount.emit(this.appInfo, this, true);\n    return true;\n  }\n\n  hide() {\n    this.active = false;\n    this.mounting = false;\n    const { display, mounted, provider } = this;\n    if (!display) return false;\n    if (!mounted) {\n      (typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false) && warn('Need to call the \"app.mount()\" method first.');\n      return false;\n    }\n    this.hooks.lifecycle.beforeUnmount.emit(this.appInfo, this, true);\n\n    this.callDestroy(provider, false);\n    this.display = false;\n    remove(this.context.activeApps, this);\n    this.hooks.lifecycle.afterUnmount.emit(this.appInfo, this, true);\n    return true;\n  }\n\n  async mount() {\n    if (!this.canMount()) return false;\n    this.hooks.lifecycle.beforeMount.emit(this.appInfo, this, false);\n\n    this.active = true;\n    this.mounting = true;\n    try {\n      this.context.activeApps.push(this);\n      // add container and compile js with cjs\n      const { asyncScripts } = await this.compileAndRenderContainer();\n      if (!this.stopMountAndClearEffect()) return false;\n\n      // Good provider is set at compile time\n      const provider = await this.getProvider();\n      // Existing asynchronous functions need to decide whether the application has been unloaded\n      if (!this.stopMountAndClearEffect()) return false;\n\n      this.callRender(provider, true);\n      this.display = true;\n      this.mounted = true;\n      this.hooks.lifecycle.afterMount.emit(this.appInfo, this, false);\n\n      await asyncScripts;\n      if (!this.stopMountAndClearEffect()) return false;\n    } catch (e) {\n      this.entryManager.DOMApis.removeElement(this.appContainer);\n      this.hooks.lifecycle.errorMountApp.emit(e, this.appInfo);\n      return false;\n    } finally {\n      this.mounting = false;\n    }\n    return true;\n  }\n\n  unmount() {\n    this.active = false;\n    this.mounting = false;\n    if (!this.mounted || !this.appContainer) {\n      return false;\n    }\n    if (this.unmounting) {\n      (typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false) && warn(`The ${this.name} app unmounting.`);\n      return false;\n    }\n    // This prevents the unmount of the current app from being called in \"provider.destroy\"\n    this.unmounting = true;\n    this.hooks.lifecycle.beforeUnmount.emit(this.appInfo, this, false);\n\n    try {\n      this.callDestroy(this.provider, true);\n      this.display = false;\n      this.mounted = false;\n      this.provider = undefined;\n      this.customExports = {};\n      this.cjsModules.exports = {};\n      this.esModuleLoader.destroy();\n      remove(this.context.activeApps, this);\n      this.hooks.lifecycle.afterUnmount.emit(this.appInfo, this, false);\n    } catch (e) {\n      remove(this.context.activeApps, this);\n      this.entryManager.DOMApis.removeElement(this.appContainer);\n      this.hooks.lifecycle.errorUnmountApp.emit(e, this.appInfo);\n      return false;\n    } finally {\n      this.unmounting = false;\n    }\n    return true;\n  }\n\n  getExecScriptEnv(noEntry?: boolean) {\n    // The legacy of commonJS function support\n    const envs = {\n      [__GARFISH_EXPORTS__]: this.customExports,\n      [__GARFISH_GLOBAL_ENV__]: this.globalEnvVariables,\n    };\n\n    if (noEntry) {\n      return {\n        ...envs,\n        require: this.cjsModules.require,\n      };\n    }\n\n    return {\n      ...envs,\n      ...this.cjsModules,\n    };\n  }\n\n  // Performs js resources provided by the module, finally get the content of the export\n  async compileAndRenderContainer() {\n    // Render the application node\n    // If you don't want to use the CJS export, at the entrance is not can not pass the module, the require\n    await this.renderTemplate();\n\n    // Execute asynchronous script\n    return {\n      asyncScripts: new Promise<void>((resolve) => {\n        // Asynchronous script does not block the rendering process\n        setTimeout(() => {\n          if (this.stopMountAndClearEffect()) {\n            for (const jsManager of this.resources.js) {\n              if (jsManager.async) {\n                try {\n                  this.execScript(\n                    jsManager.scriptCode,\n                    {},\n                    jsManager.url || this.appInfo.entry,\n                    {\n                      async: false,\n                      noEntry: true,\n                    },\n                  );\n                } catch (e) {\n                  this.hooks.lifecycle.errorMountApp.emit(e, this.appInfo);\n                }\n              }\n            }\n          }\n          resolve();\n        });\n      }),\n    };\n  }\n\n  private canMount() {\n    // If you are not in mount mount\n    if (this.mounting) {\n      (typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false) && warn(`The ${this.appInfo.name} app mounting.`);\n      return false;\n    }\n    // If the application has been rendered complete, apply colours to a drawing again, need to destroy the rendering\n    if (this.mounted) {\n      (typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false) && warn(`The ${this.appInfo.name} app already mounted.`);\n      return false;\n    }\n    // Application in destruction state, the need to destroy completed to render\n    if (this.unmounting) {\n      (typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false) &&\n        warn(\n          `The ${this.appInfo.name} app is unmounting can't Perform application rendering.`,\n        );\n      return false;\n    }\n    return true;\n  }\n\n  // If asynchronous task encountered in the rendering process, such as triggering the beforeEval before executing code,\n  // after the asynchronous task, you need to determine whether the application has been destroyed or in the end state.\n  // If in the end state will need to perform the side effects of removing rendering process, adding a mount point to a document,\n  // for example, execute code of the environmental effects, and rendering the state in the end.\n  private stopMountAndClearEffect() {\n    if (!this.active) {\n      if ((typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false)) {\n        warn(`The app \"${this.name}\" rendering process has been blocked.`);\n      }\n      this.mounting = false;\n      // Will have been added to the document flow on the container\n      if (this.appContainer) {\n        this.entryManager.DOMApis.removeElement(this.appContainer);\n      }\n      coreLog(\n        `${this.appInfo.name} id:${this.appId} stopMountAndClearEffect`,\n        this.appContainer,\n      );\n      return false;\n    }\n    return true;\n  }\n\n  // Calls to render do compatible with two different sandbox\n  private callRender(provider?: interfaces.Provider, isMount?: boolean) {\n    if (provider && provider.render) {\n      provider.render({\n        appName: this.appInfo.name,\n        dom: this.rootElement,\n        basename: this.appInfo.basename,\n        appRenderInfo: { isMount },\n        props: this.appInfo.props,\n      });\n    }\n  }\n\n  // Call to destroy do compatible with two different sandbox\n  private callDestroy(provider?: interfaces.Provider, isUnmount?: boolean) {\n    const { rootElement, appContainer } = this;\n    if (provider && provider.destroy) {\n      provider.destroy({\n        appName: this.appInfo.name,\n        dom: rootElement,\n        appRenderInfo: { isUnmount },\n        props: this.appInfo.props,\n      });\n    }\n    this.entryManager.DOMApis.removeElement(appContainer);\n  }\n\n  // Create a container node and add in the document flow\n  // domGetter Have been dealing with\n  private async addContainer() {\n    // Initialize the mount point, support domGetter as promise, is advantageous for the compatibility\n    const wrapperNode = await getRenderNode(this.appInfo.domGetter);\n    if (typeof wrapperNode.appendChild === 'function') {\n      wrapperNode.appendChild(this.appContainer);\n    }\n  }\n\n  private async renderTemplate() {\n    const { appInfo, entryManager, resources } = this;\n    const { url: baseUrl, DOMApis } = entryManager;\n    const { htmlNode, appContainer } = createAppContainer(appInfo);\n\n    // Transformation relative path\n    this.htmlNode = htmlNode;\n    this.appContainer = appContainer;\n\n    // To append to the document flow, recursive again create the contents of the HTML or execute the script\n    await this.addContainer();\n\n    const customRenderer: Parameters<typeof entryManager.createElements>[0] = {\n      meta: () => null,\n\n      img: (node) => {\n        baseUrl && entryManager.toResolveUrl(node, 'src', baseUrl);\n        return DOMApis.createElement(node);\n      },\n\n      video: (node) => {\n        baseUrl && entryManager.toResolveUrl(node, 'src', baseUrl);\n        return DOMApis.createElement(node);\n      },\n\n      audio: (node) => {\n        baseUrl && entryManager.toResolveUrl(node, 'src', baseUrl);\n        return DOMApis.createElement(node);\n      },\n\n      // The body and head this kind of treatment is to compatible with the old version\n      body: (node) => {\n        if (!this.strictIsolation) {\n          node = entryManager.cloneNode(node);\n          node.tagName = 'div';\n          node.attributes.push({\n            key: __MockBody__,\n            value: null,\n          });\n        }\n        return DOMApis.createElement(node);\n      },\n\n      head: (node) => {\n        if (!this.strictIsolation) {\n          node = entryManager.cloneNode(node);\n          node.tagName = 'div';\n          node.attributes.push({\n            key: __MockHead__,\n            value: null,\n          });\n        }\n        return DOMApis.createElement(node);\n      },\n\n      script: (node) => {\n        const mimeType = entryManager.findAttributeValue(node, 'type');\n        const isModule = mimeType === 'module';\n\n        if (mimeType) {\n          // Other script template\n          if (!isModule && !isJsType({ type: mimeType })) {\n            return DOMApis.createElement(node);\n          }\n        }\n        const jsManager = resources.js.find((manager) => {\n          return !manager.async ? manager.isSameOrigin(node) : false;\n        });\n\n        if (jsManager) {\n          const { url, scriptCode } = jsManager;\n          const mockOriginScript = document.createElement('script');\n          node.attributes.forEach((attribute)=>{\n            if (attribute.key) {\n              mockOriginScript.setAttribute(attribute.key, attribute.value || '');\n            }\n          });\n\n          const targetUrl = url || this.appInfo.entry;\n          this.execScript(scriptCode, {}, targetUrl, {\n            isModule,\n            async: false,\n            isInline: jsManager.isInlineScript(),\n            noEntry: toBoolean(\n              entryManager.findAttributeValue(node, 'no-entry')\n                || this.isNoEntryScript(targetUrl),\n            ),\n            originScript: mockOriginScript,\n          });\n        } else if ((typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false)) {\n          const async = entryManager.findAttributeValue(node, 'async');\n          if (typeof async === 'undefined' || async === 'false') {\n            const tipInfo = JSON.stringify(node, null, 2);\n            warn(\n              `Current js node cannot be found, the resource may not exist.\\n\\n ${tipInfo}`,\n            );\n          }\n        }\n        return DOMApis.createScriptCommentNode(node);\n      },\n\n      style: (node) => {\n        const text = node.children[0] as Text;\n        if (text) {\n          const styleManager = new StyleManager(text.content, baseUrl);\n          styleManager.setScope({\n            appName: this.name,\n            rootElId: this.appContainer.id,\n          });\n          baseUrl && styleManager.correctPath(baseUrl);\n          return entryManager.ignoreChildNodesCreation(\n            styleManager.renderAsStyleElement(),\n          );\n        }\n        return DOMApis.createElement(node);\n      },\n\n      link: (node) => {\n        if (DOMApis.isCssLinkNode(node)) {\n          const styleManager = this.resources.link.find((manager) =>\n            manager.isSameOrigin(node),\n          );\n          if (styleManager) {\n            styleManager.setScope({\n              appName: this.name,\n              rootElId: this.appContainer.id,\n            });\n            return styleManager.renderAsStyleElement(\n              (typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false) ? `\\n/*${DOMApis.createLinkCommentNode(node)}*/\\n` : '',\n            );\n          }\n        }\n        // prettier-ignore\n        return DOMApis.isPrefetchJsLinkNode(node)\n          ? DOMApis.createScriptCommentNode(node)\n          : DOMApis.isIconLinkNode(node)\n            ? null // Filter the icon of the child app, and cannot affect the main application\n            : DOMApis.createElement(node);\n      },\n    };\n\n    // Render dom tree and append to document.\n    entryManager.createElements(customRenderer, htmlNode);\n  }\n\n  private async checkAndGetProvider() {\n    const { appInfo, rootElement, cjsModules, customExports } = this;\n    const { name, props, basename } = appInfo;\n    let provider:\n      | ((...args: any[]) => interfaces.Provider)\n      | interfaces.Provider\n      | undefined = undefined;\n\n    // esModule export\n    await this.esmQueue.awaitCompletion();\n\n    // Cjs exports\n    if (cjsModules.exports) {\n      if (isPromise(cjsModules.exports))\n        cjsModules.exports = await cjsModules.exports;\n      // Is not set in the configuration of webpack library option\n      if (cjsModules.exports.provider) provider = cjsModules.exports.provider;\n    }\n\n    // Custom export prior to export by default\n    if (customExports.provider) {\n      provider = customExports.provider;\n    }\n\n    if (typeof provider === 'function') {\n      provider = await provider(\n        {\n          basename,\n          dom: rootElement,\n          ...(props || {}),\n        },\n        props,\n      );\n    } else if (isPromise(provider)) {\n      provider = await provider;\n    }\n\n    // The provider may be a function object\n    if (!isObject(provider) && typeof provider !== 'function') {\n      warn(\n        ` Invalid module content: ${name}, you should return both render and destroy functions in provider function.`,\n      );\n    }\n\n    // If you have customLoader, the dojo.provide by user\n    const hookRes = await (this.customLoader &&\n      this.customLoader(provider as interfaces.Provider, appInfo, basename));\n\n    if (hookRes) {\n      const { mount, unmount } = hookRes || ({} as any);\n      if (typeof mount === 'function' && typeof unmount === 'function') {\n        (provider as interfaces.Provider).render = mount;\n        (provider as interfaces.Provider).destroy = unmount;\n      }\n    }\n\n    if (!appInfo.noCheckProvider) {\n      assert(provider, `\"provider\" is \"${provider}\".`);\n      // No need to use \"hasOwn\", because \"render\" may be on the prototype chain\n      assert('render' in provider, '\"render\" is required in provider.');\n      assert('destroy' in provider, '\"destroy\" is required in provider.');\n    }\n\n    this.provider = provider as interfaces.Provider;\n    return provider as interfaces.Provider;\n  }\n}\n", "import { SyncHook, AsyncHook, PluginSystem } from '@garfish/hooks';\nimport { interfaces } from './interface';\n\n// prettier-ignore\nexport function globalLifecycle() {\n  return new PluginSystem({\n    beforeBootstrap: new SyncHook<[interfaces.Options], void>(),\n    bootstrap: new SyncHook<[interfaces.Options], void>(),\n    beforeRegisterApp: new SyncHook<[interfaces.AppInfo | Array<interfaces.AppInfo>], void>(),\n    registerApp: new SyncHook<[Record<string, interfaces.AppInfo>], void>(),\n    beforeLoad: new AsyncHook<[interfaces.AppInfo]>(),\n    afterLoad: new AsyncHook<[interfaces.AppInfo, interfaces.App | null]>(),\n    errorLoadApp: new SyncHook<[Error, interfaces.AppInfo], void>(),\n  });\n}\n\n// prettier-ignore\nexport function appLifecycle() {\n  return new PluginSystem({\n    beforeEval: new SyncHook<[\n        interfaces.AppInfo,\n        string,\n        Record<string, any>?,\n        string?,\n        { async?: boolean; noEntry?: boolean }?,\n      ],\n      void\n    >(),\n    afterEval: new SyncHook<\n      [\n        interfaces.AppInfo,\n        string,\n        Record<string, any>?,\n        string?,\n        { async?: boolean; noEntry?: boolean }?,\n      ],\n      void\n    >(),\n    beforeMount: new SyncHook<[interfaces.AppInfo, interfaces.App, boolean], void>(),\n    afterMount: new SyncHook<[interfaces.AppInfo, interfaces.App, boolean], void>(),\n    errorMountApp: new SyncHook<[Error, interfaces.AppInfo], void>(),\n    beforeUnmount: new SyncHook<[interfaces.AppInfo, interfaces.App, boolean], void>(),\n    afterUnmount: new SyncHook<[interfaces.AppInfo, interfaces.App, boolean], void>(),\n    errorUnmountApp: new SyncHook<[Error, interfaces.AppInfo], void>(),\n    errorExecCode: new SyncHook<\n      [\n        Error,\n        interfaces.AppInfo,\n        string,\n        Record<string, any>?,\n        string?,\n        { async?: boolean; noEntry?: boolean }?,\n      ],\n      void\n    >(),\n  });\n}\n", "import { ImportSpecifier, init, parse } from 'es-module-lexer';\nimport type { JavaScriptManager } from '@garfish/loader';\nimport { Lock } from '@garfish/utils';\nimport {\n  isAbsolute,\n  transformUrl,\n  haveSourcemap,\n  createSourcemap,\n} from '@garfish/utils';\nimport { interfaces } from '../interface';\nimport type { App } from './app';\n\nconst __GARFISH_ESM_ENV__ = '__GARFISH_ESM_ENV__';\n\nexport const getModuleImportProcessor = (code: string) => {\n  // split code into two segments\n  // avoid 'pause before potential out of memory crash' in chrome\n  // for super large string, it can improve performance as well\n  let finalCode = '';\n  let resetCode = code;\n  let prevCodeIndex = 0;\n  const rawImport = 'import';\n  const wrapImport = '_import_';\n  return (importAnalysis: ImportSpecifier, newModuleName = '') => {\n    const { d: importType, n: moduleName, s, e, ss, se } = importAnalysis;\n    const isDynamicImport = importType > -1;\n    if (isDynamicImport) {\n      // dynamic import\n      // replace 'import' keyword\n      const codeStart = ss - prevCodeIndex;\n      const codeEnd = se - prevCodeIndex;\n      const dynamicImportStatement = resetCode.slice(codeStart, codeEnd);\n      // append the code before import statement\n      finalCode += resetCode.slice(0, codeStart);\n      // append import statement\n      finalCode += dynamicImportStatement.replace(rawImport, wrapImport);\n      resetCode = resetCode.slice(codeEnd);\n      prevCodeIndex = se;\n    } else if (moduleName) {\n      // static import\n      // replace module name\n      const codeStart = s - prevCodeIndex;\n      const codeEnd = e - prevCodeIndex;\n      // append the code before import name\n      finalCode += resetCode.slice(0, codeStart);\n      // append new import name\n      finalCode += newModuleName;\n      resetCode = resetCode.slice(codeEnd);\n      prevCodeIndex = e;\n    }\n    return [finalCode, resetCode];\n  };\n};\n\nexport const genShellExecutionCode = (\n  id: string | number,\n  sourceModuleName: string,\n  shellUrl: string,\n) =>\n  `;import*as m$$_${id} from'${sourceModuleName}';import{u$$_ as u$$_${id}}from'${shellUrl}';u$$_${id}(m$$_${id})`;\n\ninterface ModuleCacheItem {\n  blobUrl?: string;\n  shellUrl?: string;\n  shellExecuted?: boolean;\n  analysis?: ReturnType<typeof parse>;\n  source: string;\n}\n\nexport class ESModuleLoader {\n  private app: App;\n  private globalVarKey: string;\n  private moduleCache: Record<string, ModuleCacheItem> = {};\n  private lock = new Lock();\n\n  constructor(app: App) {\n    this.app = app;\n    this.globalVarKey = `${__GARFISH_ESM_ENV__}_${this.app.appId}`;\n  }\n\n  private execModuleCode(blobUrl: string) {\n    const result = (0, eval)(`import('${blobUrl}')`);\n    this.lock.release();\n    return result;\n  }\n\n  private createBlobUrl(code: string) {\n    return URL.createObjectURL(new Blob([code], { type: 'text/javascript' }));\n  }\n\n  private setBlobUrl(saveId: string, blobUrl: string) {\n    this.moduleCache[saveId].blobUrl = blobUrl;\n  }\n\n  private async fetchModuleResource(\n    lockId: number,\n    envVarStr: string,\n    noEntryEnvVarStr: string,\n    saveUrl: string,\n    requestUrl: string,\n  ) {\n    const { resourceManager } =\n      await this.app.context.loader.load<JavaScriptManager>({\n        scope: this.app.name,\n        url: requestUrl,\n      });\n    // Maybe other resource\n    if (resourceManager) {\n      let sourcemap = '';\n      // eslint-disable-next-line prefer-const\n      let { url, scriptCode } = resourceManager;\n\n      if (!haveSourcemap(scriptCode)) {\n        sourcemap = await createSourcemap(scriptCode, requestUrl);\n      }\n      scriptCode = await this.analysisModule(\n        lockId,\n        scriptCode,\n        envVarStr,\n        noEntryEnvVarStr,\n        saveUrl,\n        url,\n      );\n      const blobUrl = this.createBlobUrl(\n        `import.meta.url='${url}';${this.app.isNoEntryScript(url) ? noEntryEnvVarStr : envVarStr}${scriptCode}\\n${sourcemap}`,\n      );\n      this.setBlobUrl(saveUrl, blobUrl);\n    }\n  }\n\n  private getUrl(referUrl, targetUrl) {\n    return !isAbsolute(targetUrl) && referUrl\n      ? transformUrl(referUrl, targetUrl)\n      : targetUrl;\n  }\n\n  private preloadStaticModuleAsync(\n    analysis: ReturnType<typeof parse>,\n    realUrl?: string | null,\n  ) {\n    const [imports] = analysis;\n\n    for (let i = 0, length = imports.length; i < length; i++) {\n      const importAnalysis = imports[i];\n      const { d: importType, n: moduleName } = importAnalysis;\n      const isDynamicImport = importType > -1;\n      if (moduleName && !isDynamicImport) {\n        // async preload all static import module of current file\n        this.app.context.loader.load<JavaScriptManager>({\n          scope: this.app.name,\n          url: this.getUrl(realUrl, moduleName),\n        });\n      }\n    }\n  }\n\n  private async analysisModule(\n    lockId: number,\n    code: string,\n    envVarStr: string,\n    noEntryEnvVarStr: string,\n    baseUrl?: string,\n    realUrl?: string | null,\n  ) {\n    // wait for the other task\n    await this.lock.wait(lockId);\n\n    // this is necessary for the Web Assembly boot\n    await init;\n\n    const analysis = parse(code, realUrl || '');\n    const thisModule: ModuleCacheItem = {\n      analysis,\n      source: code,\n    };\n\n    if (baseUrl) {\n      this.moduleCache[baseUrl] = thisModule;\n    }\n\n    let result = ['', code];\n    let shellExecutionCode = '';\n    const dynamicImport = `var _import_=(url)=>window.${this.globalVarKey}.import(url,'${baseUrl}','${realUrl}');`;\n    const processImportModule = getModuleImportProcessor(code);\n    const [imports] = analysis;\n\n    this.preloadStaticModuleAsync(analysis, realUrl);\n\n    for (let i = 0, length = imports.length; i < length; i++) {\n      const importAnalysis = imports[i];\n      const { d: importType, n: moduleName } = importAnalysis;\n      const isDynamicImport = importType > -1;\n      let saveUrl = moduleName || '';\n      let newModuleName = '';\n      if (moduleName && !isDynamicImport) {\n        // static import\n        const requestUrl = this.getUrl(realUrl, moduleName);\n        saveUrl = this.getUrl(baseUrl, moduleName);\n\n        let currentModule = this.moduleCache[saveUrl];\n        if (currentModule && !currentModule.blobUrl) {\n          // circular dependency\n          if (!currentModule.shellUrl) {\n            const [currentModuleImports, currentModuleExports] =\n              currentModule.analysis!;\n            // case 'export * from \"xxx\"'\n            // we can find this in the import statement\n            const wildcardExports = currentModuleImports.filter(\n              (importItem) => {\n                const statement = currentModule.source.substring(\n                  importItem.ss,\n                  importItem.se,\n                );\n                return /^export\\s*\\*\\s*from\\s*/.test(statement);\n              },\n            );\n            const wildcardExportStatements: string[] = [];\n            for (let j = 0, l = wildcardExports.length; j < l; j++) {\n              // find wildcard exports\n              const wildcardExport = wildcardExports[j];\n              const wildcardExportUrl = wildcardExport.n || '';\n              const wildcardExportSaveUrl = this.getUrl(\n                baseUrl,\n                wildcardExportUrl,\n              );\n              // fetch and analyze wildcard export module\n              await this.fetchModuleResource(\n                lockId,\n                envVarStr,\n                noEntryEnvVarStr,\n                wildcardExportSaveUrl,\n                this.getUrl(realUrl, wildcardExportUrl),\n              );\n              const wildcardModule = this.moduleCache[wildcardExportSaveUrl];\n              if (wildcardModule?.blobUrl) {\n                wildcardExportStatements.push(\n                  `export * from '${wildcardModule.blobUrl}'`,\n                );\n              }\n            }\n            // create a shell code for delay assignment\n            currentModule.shellUrl = this.createBlobUrl(\n              `export function u$$_(m){${currentModuleExports\n                .map((name) =>\n                  name === 'default' ? 'd$$_=m.default' : `${name}=m.${name}`,\n                )\n                .join(',')}}${currentModuleExports\n                .map((name) =>\n                  name === 'default'\n                    ? 'let d$$_;export{d$$_ as default}'\n                    : `export let ${name}`,\n                )\n                .join(';')}${\n                wildcardExportStatements.length\n                  ? `;${wildcardExportStatements.join(';')}`\n                  : ''\n              }\\n//# sourceURL=${saveUrl}?cycle`,\n            );\n          }\n          newModuleName = currentModule.shellUrl;\n        } else if (!currentModule) {\n          await this.fetchModuleResource(lockId, envVarStr, noEntryEnvVarStr, saveUrl, requestUrl);\n          currentModule = this.moduleCache[saveUrl];\n          const { blobUrl, shellUrl, shellExecuted } = currentModule;\n          newModuleName = blobUrl!;\n          if (shellUrl && !shellExecuted) {\n            // find circular shell, just execute it\n            shellExecutionCode += genShellExecutionCode(\n              i,\n              newModuleName,\n              shellUrl,\n            );\n            currentModule.shellExecuted = true;\n          }\n        } else {\n          newModuleName = currentModule.blobUrl!;\n        }\n      }\n      result = processImportModule(importAnalysis, newModuleName || moduleName);\n    }\n\n    // clear\n    thisModule.source = '';\n    delete thisModule.analysis;\n\n    return `${dynamicImport}${shellExecutionCode};${result.join('')}`;\n  }\n\n  destroy() {\n    for (const key in this.moduleCache) {\n      const { blobUrl, shellUrl } = this.moduleCache[key];\n      if (blobUrl) {\n        URL.revokeObjectURL(blobUrl);\n      }\n      if (shellUrl) {\n        URL.revokeObjectURL(shellUrl);\n      }\n    }\n    this.moduleCache = {};\n    this.lock.clear();\n    delete this.app.global[this.globalVarKey];\n  }\n\n  load(\n    code: string,\n    env: Record<string, any>,\n    url?: string,\n    options?: interfaces.ExecScriptOptions,\n  ) {\n    return new Promise<void>(async (resolve) => {\n      if (url && this.moduleCache[url]) {\n        return resolve();\n      }\n\n      const genShellCodeWrapper = (\n        blobUrl: string,\n        shellUrl: string,\n        sourceUrl: string,\n      ) => {\n        return `export * from '${blobUrl}'${genShellExecutionCode(\n          0,\n          blobUrl,\n          shellUrl,\n        )}\\n//# sourceURL=${sourceUrl}?cycle`;\n      };\n\n      env = {\n        ...env,\n        resolve,\n        import: async (moduleId: string, baseUrl: string, realUrl: string) => {\n          let saveUrl = moduleId;\n          let requestUrl = moduleId;\n\n          if (!isAbsolute(moduleId)) {\n            saveUrl = transformUrl(baseUrl, moduleId);\n            requestUrl = transformUrl(realUrl, moduleId);\n          }\n          let targetModule = this.moduleCache[saveUrl];\n          if (!targetModule?.blobUrl) {\n            await this.fetchModuleResource(this.lock.genId(), envVarStr, noEntryEnvVarStr, saveUrl, requestUrl);\n            targetModule = this.moduleCache[saveUrl];\n          }\n          if (\n            targetModule &&\n            targetModule.shellUrl &&\n            !targetModule.shellExecuted &&\n            targetModule.blobUrl\n          ) {\n            // if the top level load is a shell code, we need to run its update function\n            return this.execModuleCode(\n              this.createBlobUrl(\n                genShellCodeWrapper(\n                  targetModule.blobUrl,\n                  targetModule.shellUrl,\n                  saveUrl,\n                ),\n              ),\n            );\n          }\n          return this.execModuleCode(targetModule.blobUrl!);\n        },\n      };\n      const genEnvVarStr = (targetEnv: Record<string, any>, noEntry?: boolean) => {\n        const newEnv = { ...targetEnv };\n        if (noEntry) {\n          delete newEnv.exports;\n          delete newEnv.module;\n        }\n        return Object.keys(newEnv).reduce((prevCode, name) => {\n          if (name === 'resolve' || name === 'import') return prevCode;\n          return `${prevCode} var ${name} = window.${this.globalVarKey}.${name};`;\n        }, '');\n      };\n      const envVarStr = genEnvVarStr(env);\n      const noEntryEnvVarStr = genEnvVarStr(env, true);\n\n      let sourcemap = '';\n      if (!haveSourcemap(code) && url) {\n        sourcemap = await createSourcemap(\n          code,\n          options && options.isInline\n            ? `index.html(inline.${this.app.scriptCount}.js)`\n            : url,\n        );\n      }\n\n      code = await this.analysisModule(this.lock.genId(), code, envVarStr, noEntryEnvVarStr, url, url);\n      code = `import.meta.url='${url}';${options?.noEntry ? noEntryEnvVarStr : envVarStr}${code}\\n;window.${this.globalVarKey}.resolve();\\n${sourcemap}`;\n\n      this.app.global[this.globalVarKey] = env;\n\n      let blobUrl = this.createBlobUrl(code);\n      if (options && !options.isInline && url) {\n        this.setBlobUrl(url, blobUrl);\n      }\n      const currentModule = this.moduleCache[url || ''];\n      if (currentModule?.shellUrl && !currentModule.shellExecuted) {\n        // if the top level load is a shell code, we need to run its update function\n        blobUrl = this.createBlobUrl(\n          genShellCodeWrapper(blobUrl, currentModule.shellUrl, url || ''),\n        );\n      }\n      this.execModuleCode(blobUrl);\n    });\n  }\n}\n", "import { warn, error, Text, transformUrl, assert } from '@garfish/utils';\nimport {\n  Loader,\n  StyleManager,\n  TemplateManager,\n  JavaScriptManager,\n} from '@garfish/loader';\nimport { AppInfo } from './app';\n\n// Fetch `script`, `link` and `module meta` elements\nfunction fetchStaticResources(\n  appName: string,\n  loader: Loader,\n  entryManager: TemplateManager,\n) {\n  const isAsync = (val) => typeof val !== 'undefined' && val !== 'false';\n\n  // Get all script elements\n  const jsNodes = Promise.all(\n    entryManager\n      .findAllJsNodes()\n      .map((node) => {\n        const src = entryManager.findAttributeValue(node, 'src');\n        const type = entryManager.findAttributeValue(node, 'type');\n        const crossOrigin = entryManager.findAttributeValue(\n          node,\n          'crossorigin',\n        );\n\n        // There should be no embedded script in the script element tag with the src attribute specified\n        if (src) {\n          const fetchUrl = entryManager.url\n            ? transformUrl(entryManager.url, src)\n            : src;\n          const async = entryManager.findAttributeValue(node, 'async');\n\n          // Scripts with \"async\" attribute will make the rendering process very complicated,\n          // we have a preload mechanism, so we don\u2019t need to deal with it.\n          return loader\n            .load<JavaScriptManager>({\n              scope: appName,\n              url: fetchUrl,\n              crossOrigin,\n              defaultContentType: type,\n            })\n            .then(({ resourceManager: jsManager }) => {\n              if (jsManager) {\n                jsManager.setDep(node);\n                type && jsManager.setMimeType(type);\n                jsManager.setAsyncAttribute(isAsync(async));\n                return jsManager;\n              } else {\n                warn(`[${appName}] Failed to load script: ${fetchUrl}`);\n              }\n            })\n            .catch(() => null);\n        } else if (node.children.length > 0) {\n          const code = (node.children[0] as Text).content;\n          if (code) {\n            const jsManager = new JavaScriptManager(code, '');\n            jsManager.setDep(node);\n            type && jsManager.setMimeType(type);\n            return jsManager;\n          }\n        }\n      })\n      .filter(Boolean),\n  );\n\n  // Get all link elements\n  const linkNodes = Promise.all(\n    entryManager\n      .findAllLinkNodes()\n      .map((node) => {\n        if (!entryManager.DOMApis.isCssLinkNode(node)) return;\n        const href = entryManager.findAttributeValue(node, 'href');\n        if (href) {\n          const fetchUrl = entryManager.url\n            ? transformUrl(entryManager.url, href)\n            : href;\n          return loader\n            .load<StyleManager>({ scope: appName, url: fetchUrl })\n            .then(({ resourceManager: styleManager }) => {\n              if (styleManager) {\n                styleManager.setDep(node);\n                styleManager.correctPath();\n                return styleManager;\n              } else {\n                warn(`${appName} Failed to load link: ${fetchUrl}`);\n              }\n            })\n            .catch(() => null);\n        }\n      })\n      .filter(Boolean),\n  );\n\n  // Get all remote modules\n  const metaNodes = Promise.all(\n    entryManager\n      .findAllMetaNodes()\n      .map((node) => {\n        if (!entryManager.DOMApis.isRemoteModule(node)) return;\n        const async = entryManager.findAttributeValue(node, 'async');\n        const alias = entryManager.findAttributeValue(node, 'alias');\n        if (!isAsync(async)) {\n          const src = entryManager.findAttributeValue(node, 'src');\n          if (src) {\n            return loader\n              .loadModule(src)\n              .then(({ resourceManager: moduleManager }) => {\n                if (moduleManager && alias) {\n                  moduleManager && moduleManager.setAlias(alias);\n                }\n                return moduleManager;\n              })\n              .catch(() => null);\n          }\n        } else if (alias) {\n          warn(`Asynchronous loading module, the alias \"${alias}\" is invalid.`);\n        }\n      })\n      .filter(Boolean),\n  );\n\n  return Promise.all([jsNodes, linkNodes, metaNodes]).then((ls) =>\n    ls.map((ns: any) => ns.filter(Boolean)),\n  );\n}\n\nexport async function processAppResources(loader: Loader, appInfo: AppInfo) {\n  let isHtmlMode: Boolean = false,\n    fakeEntryManager;\n  const resources: any = { js: [], link: [], modules: [] }; // Default resources\n  assert(appInfo.entry, `[${appInfo.name}] Entry is not specified.`);\n  const { resourceManager: entryManager } = await loader.load({\n    scope: appInfo.name,\n    url: transformUrl(location.href, appInfo.entry),\n  });\n\n  // Html entry\n  if (entryManager instanceof TemplateManager) {\n    isHtmlMode = true;\n    const [js, link, modules] = await fetchStaticResources(\n      appInfo.name,\n      loader,\n      entryManager,\n    );\n    resources.js = js;\n    resources.link = link;\n    resources.modules = modules;\n  } else if (entryManager instanceof JavaScriptManager) {\n    // Js entry\n    isHtmlMode = false;\n    const mockTemplateCode = `<script src=\"${entryManager.url}\"></script>`;\n    fakeEntryManager = new TemplateManager(mockTemplateCode, entryManager.url);\n    entryManager.setDep(fakeEntryManager.findAllJsNodes()[0]);\n    resources.js = [entryManager];\n  } else {\n    error(`Entrance wrong type of resource of \"${appInfo.name}\".`);\n  }\n\n  return [fakeEntryManager || entryManager, resources, isHtmlMode];\n}\n", "import { interfaces } from '../interface';\n\n// When the main application is updated, the currently active child applications need to rerender.\nexport function GarfishHMRPlugin() {\n  let hasInit = false;\n  let isHotUpdate = false;\n  return function (Garfish: interfaces.Garfish): interfaces.Plugin {\n    return {\n      name: 'fix-hmr',\n      version: '1.12.0',\n\n      bootstrap() {\n        if (hasInit) return;\n        hasInit = true;\n\n        let webpackHotUpdateName = 'webpackHotUpdate';\n        let webpackHotUpdate = (window as any)[webpackHotUpdateName];\n\n        // \u67E5\u627E webpackHotUpdate \u51FD\u6570\n        for (const i in window) {\n          if (i.includes('webpackHotUpdate')) {\n            webpackHotUpdateName = i;\n            webpackHotUpdate = window[i];\n          }\n        }\n\n        if (typeof webpackHotUpdate === 'function') {\n          (window as any)[webpackHotUpdateName] = function () {\n            isHotUpdate = true;\n            return webpackHotUpdate.apply(this, arguments);\n          };\n\n          const observer = new MutationObserver(() => {\n            if (!isHotUpdate) return;\n            isHotUpdate = false;\n\n            Garfish.activeApps.forEach((app) => {\n              if (app.mounted) {\n                setTimeout(() => {\n                  app.display && app.hide();\n                  app.show();\n                });\n              }\n            });\n          });\n\n          observer.observe(document.documentElement, {\n            subtree: true,\n            childList: true,\n            attributes: true,\n          });\n        }\n      },\n    };\n  };\n}\n", "import { interfaces } from '../interface';\n\nexport function GarfishOptionsLife(options, name: string) {\n  return function (): interfaces.Plugin {\n    return {\n      name,\n      version: '1.12.0',\n      ...options,\n    };\n  };\n}\n", "import {\n  warn,\n  Queue,\n  isAbsolute,\n  transformUrl,\n  idleCallback,\n  callTestCallback,\n  safeWrapper,\n} from '@garfish/utils';\nimport { Loader, Manager, TemplateManager } from '@garfish/loader';\nimport { interfaces } from '../interface';\n\nexport const storageKey = '__garfishPreloadApp__';\n\nconst isMobile =\n  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    navigator.userAgent,\n  );\n\n// Using queues, to avoid interference with the normal request\nconst requestQueue = new Queue();\n\nconst isSlowNetwork = () =>\n  (navigator as any).connection\n    ? (navigator as any).connection.saveData ||\n      /(2|3)g/.test((navigator as any).connection.effectiveType)\n    : false;\n\nexport const requestIdleCallback =\n  false || typeof idleCallback !== 'function'\n    ? window.setTimeout\n    : idleCallback;\n\n// Test size, catch mistakes, avoid preload first screen white during parsing error\nfunction safeLoad({\n  loader,\n  appName,\n  url,\n  isModule,\n  immediately,\n  callback,\n}: {\n  loader: Loader;\n  appName: string;\n  url: string;\n  isModule: boolean;\n  immediately: boolean;\n  callback?: (m: Manager) => any;\n}) {\n  const generateSuccess =\n    (next: () => void = () => {}) =>\n    ({ resourceManager }) => {\n      callback && callback(resourceManager);\n      setTimeout(next, 500);\n    };\n\n  const generateThrowWarn =\n    (next: () => void = () => {}) =>\n    (e) => {\n      if ((typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false)) {\n        warn(e);\n        warn(`Preload failed. \"${url}\"`);\n      }\n      next();\n    };\n\n  const loadResource = (next: () => void = () => {}) => {\n    const throwWarn = generateThrowWarn(next);\n    const success = generateSuccess(next);\n    try {\n      if (isModule) {\n        loader.loadModule(url).then(success, throwWarn);\n      } else {\n        loader.load({ scope: appName, url }).then(success, throwWarn);\n      }\n    } catch (e) {\n      throwWarn(e);\n      next();\n    }\n  };\n\n  if (immediately) {\n    loadResource();\n  } else {\n    requestQueue.add((next) => {\n      requestIdleCallback(() => loadResource(next));\n    });\n  }\n}\n\nexport function loadAppResource(\n  loader: Loader,\n  info: interfaces.AppInfo,\n  immediately = false,\n) {\n  false && callTestCallback(loadAppResource, info);\n  const fetchUrl = transformUrl(location.href, info.entry);\n\n  safeLoad({\n    loader,\n    appName: info.name,\n    url: fetchUrl,\n    isModule: false,\n    immediately,\n    callback: (manager) => {\n      const loadStaticResource = () => {\n        if (manager instanceof TemplateManager) {\n          const baseUrl = manager.url;\n          const jsNodes = manager.findAllJsNodes();\n          const linkNodes = manager.findAllLinkNodes();\n          const metaNodes = manager.findAllMetaNodes();\n\n          if (jsNodes) {\n            jsNodes.forEach((node) => {\n              const src = manager.findAttributeValue(node, 'src');\n              src &&\n                safeLoad({\n                  loader,\n                  appName: info.name,\n                  url: baseUrl ? transformUrl(baseUrl, src) : src,\n                  isModule: false,\n                  immediately,\n                });\n            });\n          }\n          if (linkNodes) {\n            linkNodes.forEach((node) => {\n              if (manager.DOMApis.isCssLinkNode(node)) {\n                const href = manager.findAttributeValue(node, 'href');\n                href &&\n                  safeLoad({\n                    loader,\n                    appName: info.name,\n                    url: baseUrl ? transformUrl(baseUrl, href) : href,\n                    isModule: false,\n                    immediately,\n                  });\n              }\n            });\n          }\n          if (metaNodes) {\n            metaNodes.forEach((node) => {\n              if (manager.DOMApis.isRemoteModule(node)) {\n                const src = manager.findAttributeValue(node, 'src');\n                if (src && isAbsolute(src)) {\n                  safeLoad({\n                    loader,\n                    appName: info.name,\n                    url: src,\n                    isModule: true,\n                    immediately,\n                  });\n                } else {\n                  warn(\n                    `The loading of the remote module must be an absolute path. \"${src}\"`,\n                  );\n                }\n              }\n            });\n          }\n        }\n      };\n      if (immediately) {\n        loadStaticResource();\n      } else {\n        requestIdleCallback(loadStaticResource);\n      }\n    },\n  });\n}\n\nexport function getRanking() {\n  const str = localStorage.getItem(storageKey);\n  if (str) {\n    const data = JSON.parse(str);\n    return data.sort((a, b) => b.count - a.count);\n  }\n  return [];\n}\n\nexport function setRanking(appName: string) {\n  const str = localStorage.getItem(storageKey);\n  const newCurrent = { appName, count: 1 };\n\n  if (!str) {\n    safeWrapper(() =>\n      localStorage.setItem(storageKey, JSON.stringify([newCurrent])),\n    );\n  } else {\n    const data = JSON.parse(str);\n    const current = data.find((app) => app.appName === appName);\n    current ? current.count++ : data.push(newCurrent);\n    safeWrapper(() => localStorage.setItem(storageKey, JSON.stringify(data)));\n  }\n}\n\nconst loadedMap = Object.create(null); // Global cache, only load again is enough\n\ndeclare module '@garfish/core' {\n  export default interface Garfish {\n    preloadApp: (appName: string) => void;\n  }\n}\n\nexport function GarfishPreloadPlugin() {\n  return function (Garfish: interfaces.Garfish): interfaces.Plugin {\n    Garfish.preloadApp = (appName) => {\n      loadAppResource(Garfish.loader, Garfish.appInfos[appName], true);\n    };\n\n    return {\n      name: 'preload',\n      version: '1.12.0',\n\n      beforeLoad(appInfo) {\n        if (Garfish.options.disablePreloadApp) {\n          return;\n        }\n        setRanking(appInfo.name);\n      },\n\n      registerApp(appInfos) {\n        // Through disablePreloadApp preload is prohibited\n        if (Garfish.options.disablePreloadApp) {\n          return;\n        }\n        setTimeout(\n          () => {\n            if (isMobile || isSlowNetwork()) return;\n            const ranking = getRanking();\n\n            for (const { appName } of ranking) {\n              if (appInfos[appName] && !loadedMap[appName]) {\n                loadedMap[appName] = true;\n                loadAppResource(Garfish.loader, appInfos[appName]);\n              }\n            }\n\n            for (const key in appInfos) {\n              if (!loadedMap[key]) {\n                loadAppResource(Garfish.loader, appInfos[key]);\n              }\n            }\n          },\n          false ? 0 : 5000,\n        );\n      },\n    };\n  };\n}\n", "import { getRenderNode, warn } from '@garfish/utils';\nimport { interfaces } from '../../interface';\n\n// Child app performance monitoring tools\ninterface PerformanceData {\n  resourceLoadTime: number;\n  blankScreenTime: number;\n  firstScreenTime: number;\n  isFirstRender: boolean;\n  entry: string;\n  action: string;\n}\n\ninterface CallbackFunction {\n  (performanceData: PerformanceData): void;\n}\n\ninterface Config {\n  attributes: boolean;\n  childList: boolean;\n  subtree: boolean;\n}\n\ninterface IOptions {\n  subAppRootSelector: interfaces.DomGetter;\n  domObserverMaxTime?: number;\n  waitSubAppNotifyMaxTime?: number;\n  observeConfig?: Config;\n}\n\nexport class SubAppObserver {\n  private observer: MutationObserver;\n  private timeLag: number;\n  private reportTimeLag: number;\n  private observeTimer: number;\n  private dataTimer: number;\n  private entry: string;\n  private subAppBeforeLoadTime: number;\n  private subAppBeforeMountTime: number;\n  private subAppStartPageShowTime: number;\n  private subAppPageShowTime: number;\n  private domQuerySelector: interfaces.DomGetter;\n  private finishAction: string;\n  private config: Config;\n  private isRecordFinish: boolean;\n  private isCallBackFinish: boolean;\n  private isStartShowFlag: boolean;\n  private isSubAppNotifyFinish: boolean;\n  private targetSubscriber: CallbackFunction[];\n  private cbEntryList: string[];\n  private performanceData: PerformanceData;\n\n  constructor(options: IOptions) {\n    this.observer = new MutationObserver(\n      this._mutationObserverCallback.bind(this),\n    );\n    this.subAppBeforeLoadTime = 0;\n    this.subAppBeforeMountTime = 0;\n    this.subAppStartPageShowTime = 0;\n    this.subAppPageShowTime = 0;\n    this.entry = '';\n    this.observeTimer = 0;\n    this.dataTimer = 0;\n    this.domQuerySelector = options.subAppRootSelector;\n    this.config = { attributes: true, childList: true, subtree: true };\n    this.targetSubscriber = [];\n    this.timeLag = options.domObserverMaxTime || 3000;\n    this.reportTimeLag = options.waitSubAppNotifyMaxTime || 10000;\n    this.isRecordFinish = false;\n    this.cbEntryList = [];\n    this.isStartShowFlag = true;\n    this.isCallBackFinish = false;\n    this.isSubAppNotifyFinish = false;\n    this.finishAction = '';\n    this.performanceData = {\n      resourceLoadTime: 0,\n      blankScreenTime: 0,\n      firstScreenTime: 0,\n      isFirstRender: true,\n      entry: '',\n      action: '',\n    };\n  }\n\n  subscribePerformanceData(callback: CallbackFunction) {\n    try {\n      this.targetSubscriber.push(callback);\n    } catch (e) {\n      warn(e);\n    }\n  }\n\n  subscribePerformanceDataOnce(callback: CallbackFunction) {\n    try {\n      const wrapCallback = (performanceData) => {\n        callback(performanceData);\n        this.unsubscribePerformanceData(wrapCallback);\n      };\n\n      this.targetSubscriber.push(wrapCallback);\n    } catch (e) {\n      warn(e);\n    }\n  }\n\n  unsubscribePerformanceData(callback: CallbackFunction) {\n    try {\n      this.targetSubscriber = this.targetSubscriber.filter(\n        (sub) => sub === callback,\n      );\n    } catch (e) {\n      warn(e);\n    }\n  }\n\n  subAppBeforeLoad(entry: string) {\n    this.entry = entry;\n    this.isRecordFinish = false;\n    this.isSubAppNotifyFinish = false;\n    this.subAppBeforeLoadTime = performance.now();\n    this.isCallBackFinish = false;\n    this._handleSubscribeCallback(false);\n  }\n\n  subAppBeforeMount() {\n    this.subAppBeforeMountTime = performance.now();\n    this._subAppStartObserver();\n  }\n\n  subAppUnmount() {\n    if (!this.isRecordFinish) {\n      this._subAppEndObserver('subAppUnmount');\n    }\n    this._handleSubscribeCallback(true);\n  }\n\n  // The child app actively notifies the first screen loading is complete\n  afterRenderNotify() {\n    if (!this.isRecordFinish) {\n      // If the monitoring rendering has not ended, actively stop the observation and process the data\n      this._subAppEndObserver('SubAppRenderNotify');\n    } else if (!this.isSubAppNotifyFinish) {\n      // If the monitoring rendering has ended, actively update the processed data\n      this.isSubAppNotifyFinish = true;\n      this.isRecordFinish = true;\n      this.finishAction = 'SubAppRenderNotify';\n      this._subAppPerformanceDataHandle();\n    }\n  }\n\n  private _mutationObserverCallback() {\n    // Start rendering elements in the child app container to record the dot\n    if (this.isStartShowFlag) {\n      this.subAppStartPageShowTime = performance.now();\n      this.isStartShowFlag = false;\n    }\n\n    // The rendering elements in the child app container no longer change for a certain period of time\n    clearTimeout(this.observeTimer);\n    this.observeTimer = setTimeout(() => {\n      clearTimeout(this.observeTimer);\n      if (!this.isRecordFinish) {\n        this._subAppEndObserver('MutationObserver');\n      }\n    }, this.timeLag) as unknown as number;\n  }\n\n  private _subAppEndObserver(finishAction: string) {\n    this.isRecordFinish = true;\n    this.finishAction = finishAction;\n    this.subAppPageShowTime = performance.now();\n    this.observer.disconnect();\n    this._subAppPerformanceDataHandle();\n    this.isStartShowFlag = true;\n  }\n\n  private async _subAppStartObserver() {\n    try {\n      const targetNode = await getRenderNode(this.domQuerySelector);\n      this.observer.observe(targetNode, this.config);\n      this._subAppClickEventObserver(targetNode as HTMLElement);\n    } catch (e) {\n      warn(e);\n    }\n  }\n\n  private _subAppPerformanceDataHandle() {\n    const timeDifference =\n      this.finishAction === 'MutationObserver' ? this.timeLag : 0;\n    this.performanceData = {\n      resourceLoadTime: this.subAppBeforeMountTime - this.subAppBeforeLoadTime,\n      blankScreenTime: this.subAppStartPageShowTime - this.subAppBeforeLoadTime,\n      firstScreenTime:\n        this.subAppPageShowTime - this.subAppBeforeLoadTime - timeDifference,\n      isFirstRender: this.cbEntryList.indexOf(this.entry) === -1,\n      entry: this.entry,\n      action: this.finishAction,\n    };\n  }\n\n  private _subAppClickEventObserver(targetNode: HTMLElement) {\n    const eventCallback = () => {\n      clearTimeout(this.observeTimer);\n      if (!this.isRecordFinish) {\n        this._subAppEndObserver('UserEvent');\n      }\n    };\n    targetNode.addEventListener('click', eventCallback);\n    targetNode.addEventListener('keyup', eventCallback);\n    targetNode.addEventListener('keydown', eventCallback);\n    targetNode.addEventListener('keypress', eventCallback);\n  }\n\n  private _handleCallback() {\n    try {\n      this.isCallBackFinish = true;\n      this.targetSubscriber.forEach((callback) => {\n        const {\n          firstScreenTime,\n          blankScreenTime,\n          resourceLoadTime,\n          action,\n          entry,\n        } = this.performanceData;\n        if (\n          firstScreenTime > 0 &&\n          blankScreenTime > 0 &&\n          resourceLoadTime > 0 &&\n          action &&\n          entry\n        ) {\n          if ((typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false)) {\n            console.warn('SUCCESS: ', this.performanceData);\n          }\n          this.cbEntryList.push(this.entry);\n          callback(this.performanceData);\n        } else if ((typeof process !== \"undefined\" && process.env && process.env.NODE_ENV ? (process.env.NODE_ENV !== \"production\") : false)) {\n          console.warn('ERROR: ', this.performanceData);\n        }\n      });\n    } catch (e) {\n      warn(e);\n    }\n  }\n\n  private _handleSubscribeCallback(isImmediately: boolean) {\n    try {\n      clearTimeout(this.dataTimer);\n      if (isImmediately && !this.isCallBackFinish) {\n        this._handleCallback();\n      } else {\n        this.dataTimer = setTimeout(() => {\n          this._handleCallback();\n        }, this.reportTimeLag) as unknown as number;\n      }\n    } catch (e) {\n      warn(e);\n    }\n  }\n}\n", "import { getRenderNode } from '@garfish/utils';\nimport { interfaces } from '../../index';\nimport { SubAppObserver } from './subAppObserver';\n\n// Key nodes in Garfish corresponding to the life cycle of registration\nexport function GarfishPerformance() {\n  return function (): interfaces.Plugin {\n    const subAppMap = {};\n    return {\n      name: 'performance',\n\n      beforeLoad(appInfo) {\n        if (!subAppMap[appInfo.name] && appInfo.domGetter) {\n          subAppMap[appInfo.name] = new SubAppObserver({\n            subAppRootSelector: appInfo.domGetter,\n          });\n        }\n        subAppMap[appInfo.name].subAppBeforeLoad(appInfo.entry);\n      },\n\n      afterLoad(appInfo, appInstance: interfaces.App) {\n        if (appInstance) {\n          appInstance.appPerformance = subAppMap[appInfo.name] as any;\n        }\n      },\n\n      beforeMount(appInfo) {\n        subAppMap[appInfo.name].subAppBeforeMount(appInfo.entry);\n      },\n\n      beforeUnmount(appInfo) {\n        subAppMap[appInfo.name].subAppUnmount(appInfo.entry);\n      },\n    };\n  };\n}\n", "import { coreLog } from '@garfish/utils';\nimport { interfaces } from '../interface';\n\nexport function GarfishLogger() {\n  return function (): interfaces.Plugin {\n    return {\n      name: 'garfish-logger',\n      version: '1.12.0',\n      beforeLoad(appInfo, ...args) {\n        coreLog(`${appInfo.name} beforeLoad`, [appInfo, ...args]);\n      },\n      afterLoad(appInfo, appInstance, ...args) {\n        if (appInstance) {\n          coreLog(`${appInfo.name} id: ${appInstance.appId} afterLoad`, [\n            appInfo,\n            ...args,\n          ]);\n        }\n      },\n      beforeMount(appInfo, appInstance, ...args) {\n        coreLog(`${appInfo.name} id: ${appInstance.appId} beforeMount`, [\n          appInfo,\n          ...args,\n        ]);\n      },\n      afterMount(appInfo, appInstance, ...args) {\n        coreLog(`${appInfo.name} id: ${appInstance.appId} afterMount`, [\n          appInfo,\n          ...args,\n        ]);\n      },\n      beforeUnmount(appInfo, appInstance, ...args) {\n        coreLog(`${appInfo.name} id: ${appInstance.appId} beforeUnmount`, [\n          appInfo,\n          ...args,\n        ]);\n      },\n      afterUnmount(appInfo, appInstance, ...args) {\n        coreLog(`${appInfo.name} id: ${appInstance.appId} afterUnmount`, [\n          appInfo,\n          ...args,\n        ]);\n      },\n    };\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
