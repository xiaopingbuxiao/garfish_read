var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/reactBridge.ts
import * as React from "react";
import { createRoot, hydrateRoot } from "react-dom/client";
import { warn } from "@garfish/utils";
var defaultOpts = {
  rootComponent: void 0,
  loadRootComponent: void 0,
  renderType: void 0,
  errorBoundary: void 0,
  el: void 0,
  canUpdate: true,
  suppressComponentDidCatchWarning: false,
  domElements: {},
  renderResults: {},
  updateResolves: {}
};
function reactBridge(userOpts) {
  if (typeof userOpts !== "object") {
    throw new Error("garfish-react-bridge requires a configuration object");
  }
  const opts = __spreadValues(__spreadValues({}, defaultOpts), userOpts);
  opts.React = opts.React || React;
  opts.createRoot = opts.createRoot || createRoot;
  opts.hydrateRoot = opts.hydrateRoot || hydrateRoot;
  if (!opts.rootComponent && !opts.loadRootComponent) {
    throw new Error("garfish-react-bridge must be passed opts.rootComponent or opts.loadRootComponent");
  }
  if (opts.errorBoundary && typeof opts.errorBoundary !== "function") {
    throw Error("The errorBoundary opt for garfish-react-bridge must either be omitted or be a function that returns React elements");
  }
  if (!atLeastReact18(opts.React)) {
    throw Error("Please make sure than the react version is higher than or equal to v18.");
  }
  const providerLifeCycle = {
    render: (appInfo) => mount.call(this, opts, appInfo),
    destroy: (appInfo) => unmount.call(this, opts, appInfo)
  };
  const provider = async function(appInfo, props) {
    await bootstrap.call(this, opts, appInfo, props);
    return providerLifeCycle;
  };
  if (window.__GARFISH__ && typeof __GARFISH_EXPORTS__ === "object" && __GARFISH_EXPORTS__) {
    __GARFISH_EXPORTS__.provider = provider;
  }
  return provider;
}
function bootstrap(opts, appInfo, props) {
  if (opts.loadRootComponent) {
    return opts.loadRootComponent(__spreadProps(__spreadValues({}, appInfo), {
      props
    })).then((resolvedComponent) => {
      opts.rootComponent = resolvedComponent;
    });
  } else {
    return Promise.resolve();
  }
}
function mount(opts, appInfo) {
  if (!opts.suppressComponentDidCatchWarning && atLeastReact18(opts.React) && !opts.errorBoundary) {
    if (!opts.rootComponent.prototype) {
      warn(`garfish-react-bridge: ${appInfo.appName}'s rootComponent does not implement an error boundary.  If using a functional component, consider providing an opts.errorBoundary to reactBridge(opts).`);
    } else if (!opts.rootComponent.prototype.componentDidCatch) {
      warn(`garfish-react-bridge: ${appInfo.appName}'s rootComponent should implement componentDidCatch to avoid accidentally unmounting the entire garfish application.`);
    }
  }
  const elementToRender = getElementToRender(opts, appInfo);
  const domElement = chooseDomElementGetter(opts, appInfo);
  const renderResult = callCreateRoot({
    elementToRender,
    domElement,
    opts
  });
  if (opts.domElements) {
    opts.domElements[appInfo.appName] = domElement;
  }
  if (opts.renderResults) {
    opts.renderResults[appInfo.appName] = renderResult;
  }
}
function unmount(opts, appInfo) {
  if (opts.renderResults) {
    const root = opts.renderResults[appInfo.appName];
    root.unmount();
    opts.domElements && delete opts.domElements[appInfo.appName];
    delete opts.renderResults[appInfo.appName];
  }
}
function atLeastReact18(React2) {
  if (React2 && typeof React2.version === "string" && React2.version.indexOf(".") >= 0) {
    const majorVersionString = React2.version.split(".")[0];
    try {
      return Number(majorVersionString) >= 18;
    } catch (err) {
      return false;
    }
  } else {
    return false;
  }
}
function callCreateRoot({ opts, elementToRender, domElement }) {
  const renderType = typeof opts.renderType === "function" ? opts.renderType() : opts.renderType;
  let root;
  if (renderType === "hydrate") {
    root = opts.hydrateRoot(elementToRender, domElement);
    root.render(elementToRender);
  } else {
    root = opts.createRoot(domElement);
    root.render(elementToRender);
  }
  return root;
}
function getElementToRender(opts, appInfo) {
  var _a, _b;
  const rootComponentElement = (_a = opts.React) == null ? void 0 : _a.createElement(opts.rootComponent, appInfo);
  let elementToRender = rootComponentElement;
  if (opts.errorBoundary) {
    elementToRender = (_b = opts.React) == null ? void 0 : _b.createElement(createErrorBoundary(opts), appInfo, elementToRender);
  }
  return elementToRender;
}
function createErrorBoundary(opts) {
  function GarfishSubAppReactErrorBoundary(appInfo) {
    var _a;
    (_a = opts.React) == null ? void 0 : _a.Component.apply(this, arguments);
    this.state = {
      caughtError: null,
      caughtErrorInfo: null
    };
    GarfishSubAppReactErrorBoundary.displayName = `ReactBridgeReactErrorBoundary(${appInfo.appName})`;
  }
  GarfishSubAppReactErrorBoundary.prototype = opts.React && Object.create(opts.React.Component.prototype);
  GarfishSubAppReactErrorBoundary.prototype.render = function() {
    if (this.state.caughtError) {
      const errorBoundary = opts.errorBoundary;
      return errorBoundary && errorBoundary(this.state.caughtError, this.props);
    } else {
      return this.props.children;
    }
  };
  GarfishSubAppReactErrorBoundary.prototype.componentDidCatch = function(err, info) {
    this.setState({
      caughtError: err,
      caughtErrorInfo: info
    });
  };
  return GarfishSubAppReactErrorBoundary;
}
function chooseDomElementGetter(opts, appInfo) {
  const { dom: container } = appInfo;
  let el;
  if (typeof opts.el === "string") {
    el = container.querySelector(opts.el);
  } else {
    el = container;
  }
  if (!(el instanceof HTMLElement)) {
    throw Error(`react bridge's dom-element-getter-helpers: el is an invalid dom element for application'${appInfo.appName}'. Expected HTMLElement, received ${typeof el}`);
  }
  return el;
}
export {
  reactBridge
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vc3JjL3JlYWN0QnJpZGdlLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBUaGUgbG9naWMgb2YgcmVhY3RCcmlkZ2UgaXMgcmVmZXJlbmNlZCBmcm9tIHNpbmdsZS1zcGEgdHlwb2dyYXBoeVxuLy8gQmVjYXVzZSB0aGUgR2FyZmlzaCBsaWZlY3ljbGUgZG9lcyBub3QgYWdyZWUgd2l0aCB0aGF0IG9mIHNpbmdsZS1zcGEgIHBhcnQgbG9naWNhbCBjb3VwbGluZyBpbiB0aGUgZnJhbWV3b3JrXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZ2xlLXNwYS9zaW5nbGUtc3BhLXJlYWN0L2Jsb2IvbWFpbi9zcmMvc2luZ2xlLXNwYS1yZWFjdC5qc1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVSb290LCBoeWRyYXRlUm9vdCwgUm9vdCB9IGZyb20gJ3JlYWN0LWRvbS9jbGllbnQnO1xuaW1wb3J0IHR5cGUgeyBVc2VyT3B0aW9ucywgUHJvcHNJbmZvIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnQGdhcmZpc2gvdXRpbHMnO1xuXG50eXBlIHR5cGVSZWFjdCA9IHR5cGVvZiBSZWFjdDtcblxudHlwZSBPcHRpb25zID0gVXNlck9wdGlvbnM8XG4gIHR5cGVvZiBSZWFjdCxcbiAgdHlwZW9mIGNyZWF0ZVJvb3QsXG4gIHR5cGVvZiBoeWRyYXRlUm9vdCxcbiAgUm9vdCxcbiAgYW55LFxuICBSZWFjdC5SZWFjdE5vZGVcbj47XG5cbmNvbnN0IGRlZmF1bHRPcHRzID0ge1xuICAvLyByZXF1aXJlZCAtIG9uZSBvciB0aGUgb3RoZXIgb3IgYm90aFxuICByb290Q29tcG9uZW50OiB1bmRlZmluZWQsXG4gIGxvYWRSb290Q29tcG9uZW50OiB1bmRlZmluZWQsXG5cbiAgLy8gb3B0aW9uYWwgb3B0c1xuICByZW5kZXJUeXBlOiB1bmRlZmluZWQsXG4gIGVycm9yQm91bmRhcnk6IHVuZGVmaW5lZCxcbiAgZWw6IHVuZGVmaW5lZCxcbiAgY2FuVXBkYXRlOiB0cnVlLCAvLyBieSBkZWZhdWx0LCBhbGxvdyBwYXJjZWxzIGNyZWF0ZWQgd2l0aCBnYXJmaXNoLXJlYWN0LWJyaWRnZSB0byBiZSB1cGRhdGVkXG4gIHN1cHByZXNzQ29tcG9uZW50RGlkQ2F0Y2hXYXJuaW5nOiBmYWxzZSxcbiAgZG9tRWxlbWVudHM6IHt9LFxuICByZW5kZXJSZXN1bHRzOiB7fSxcbiAgdXBkYXRlUmVzb2x2ZXM6IHt9LFxufTtcblxuZGVjbGFyZSBjb25zdCBfX0dBUkZJU0hfRVhQT1JUU19fOiB7XG4gIHByb3ZpZGVyOiBPYmplY3Q7XG59O1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fR0FSRklTSF9fOiBib29sZWFuO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFjdEJyaWRnZSh0aGlzOiBhbnksIHVzZXJPcHRzOiBPcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdXNlck9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnYXJmaXNoLXJlYWN0LWJyaWRnZSByZXF1aXJlcyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0Jyk7XG4gIH1cblxuICBjb25zdCBvcHRzOiBPcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRPcHRzLFxuICAgIC4uLnVzZXJPcHRzLFxuICB9O1xuXG4gIG9wdHMuUmVhY3QgPSBvcHRzLlJlYWN0IHx8IFJlYWN0O1xuICBvcHRzLmNyZWF0ZVJvb3QgPSBvcHRzLmNyZWF0ZVJvb3QgfHwgY3JlYXRlUm9vdDtcbiAgb3B0cy5oeWRyYXRlUm9vdCA9IG9wdHMuaHlkcmF0ZVJvb3QgfHwgaHlkcmF0ZVJvb3Q7XG5cbiAgaWYgKCFvcHRzLnJvb3RDb21wb25lbnQgJiYgIW9wdHMubG9hZFJvb3RDb21wb25lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnZ2FyZmlzaC1yZWFjdC1icmlkZ2UgbXVzdCBiZSBwYXNzZWQgb3B0cy5yb290Q29tcG9uZW50IG9yIG9wdHMubG9hZFJvb3RDb21wb25lbnQnLFxuICAgICk7XG4gIH1cblxuICBpZiAob3B0cy5lcnJvckJvdW5kYXJ5ICYmIHR5cGVvZiBvcHRzLmVycm9yQm91bmRhcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgICdUaGUgZXJyb3JCb3VuZGFyeSBvcHQgZm9yIGdhcmZpc2gtcmVhY3QtYnJpZGdlIG11c3QgZWl0aGVyIGJlIG9taXR0ZWQgb3IgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgUmVhY3QgZWxlbWVudHMnLFxuICAgICk7XG4gIH1cbiAgaWYgKCFhdExlYXN0UmVhY3QxOChvcHRzLlJlYWN0KSkge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgJ1BsZWFzZSBtYWtlIHN1cmUgdGhhbiB0aGUgcmVhY3QgdmVyc2lvbiBpcyBoaWdoZXIgdGhhbiBvciBlcXVhbCB0byB2MTguJyxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgcHJvdmlkZXJMaWZlQ3ljbGUgPSB7XG4gICAgcmVuZGVyOiAoYXBwSW5mbzogUHJvcHNJbmZvKSA9PiBtb3VudC5jYWxsKHRoaXMsIG9wdHMsIGFwcEluZm8pLFxuICAgIGRlc3Ryb3k6IChhcHBJbmZvOiBQcm9wc0luZm8pID0+IHVubW91bnQuY2FsbCh0aGlzLCBvcHRzLCBhcHBJbmZvKSxcbiAgICAvLyB1cGRhdGU6IChhcHBJbmZvOiBQcm9wc0luZm8pID0+XG4gICAgLy8gICBvcHRzLmNhblVwZGF0ZSAmJiB1cGRhdGUuY2FsbCh0aGlzLCBvcHRzLCBhcHBJbmZvKSxcbiAgfTtcblxuICBjb25zdCBwcm92aWRlciA9IGFzeW5jIGZ1bmN0aW9uICh0aGlzOiBhbnksIGFwcEluZm8sIHByb3BzKSB7XG4gICAgYXdhaXQgYm9vdHN0cmFwLmNhbGwodGhpcywgb3B0cywgYXBwSW5mbywgcHJvcHMpO1xuICAgIHJldHVybiBwcm92aWRlckxpZmVDeWNsZTtcbiAgfTtcblxuICBpZiAoXG4gICAgd2luZG93Ll9fR0FSRklTSF9fICYmXG4gICAgdHlwZW9mIF9fR0FSRklTSF9FWFBPUlRTX18gPT09ICdvYmplY3QnICYmXG4gICAgX19HQVJGSVNIX0VYUE9SVFNfX1xuICApIHtcbiAgICBfX0dBUkZJU0hfRVhQT1JUU19fLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gIH1cbiAgcmV0dXJuIHByb3ZpZGVyO1xufVxuXG5mdW5jdGlvbiBib290c3RyYXAob3B0czogT3B0aW9ucywgYXBwSW5mbywgcHJvcHMpIHtcbiAgaWYgKG9wdHMubG9hZFJvb3RDb21wb25lbnQpIHtcbiAgICAvLyBUaGV5IHBhc3NlZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZWFjdCBjb21wb25lbnQuIFdhaXQgZm9yIGl0IHRvIHJlc29sdmUgYmVmb3JlIG1vdW50aW5nXG4gICAgcmV0dXJuIG9wdHNcbiAgICAgIC5sb2FkUm9vdENvbXBvbmVudCh7XG4gICAgICAgIC4uLmFwcEluZm8sXG4gICAgICAgIHByb3BzLFxuICAgICAgfSlcbiAgICAgIC50aGVuKChyZXNvbHZlZENvbXBvbmVudCkgPT4ge1xuICAgICAgICBvcHRzLnJvb3RDb21wb25lbnQgPSByZXNvbHZlZENvbXBvbmVudDtcbiAgICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBjbGFzcyBvciBzdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50KG9wdHM6IE9wdGlvbnMsIGFwcEluZm86IFByb3BzSW5mbykge1xuICBpZiAoXG4gICAgIW9wdHMuc3VwcHJlc3NDb21wb25lbnREaWRDYXRjaFdhcm5pbmcgJiZcbiAgICBhdExlYXN0UmVhY3QxOChvcHRzLlJlYWN0KSAmJlxuICAgICFvcHRzLmVycm9yQm91bmRhcnlcbiAgKSB7XG4gICAgaWYgKCFvcHRzLnJvb3RDb21wb25lbnQucHJvdG90eXBlKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgZ2FyZmlzaC1yZWFjdC1icmlkZ2U6ICR7YXBwSW5mby5hcHBOYW1lfSdzIHJvb3RDb21wb25lbnQgZG9lcyBub3QgaW1wbGVtZW50IGFuIGVycm9yIGJvdW5kYXJ5LiAgSWYgdXNpbmcgYSBmdW5jdGlvbmFsIGNvbXBvbmVudCwgY29uc2lkZXIgcHJvdmlkaW5nIGFuIG9wdHMuZXJyb3JCb3VuZGFyeSB0byByZWFjdEJyaWRnZShvcHRzKS5gLFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFvcHRzLnJvb3RDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudERpZENhdGNoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgZ2FyZmlzaC1yZWFjdC1icmlkZ2U6ICR7YXBwSW5mby5hcHBOYW1lfSdzIHJvb3RDb21wb25lbnQgc2hvdWxkIGltcGxlbWVudCBjb21wb25lbnREaWRDYXRjaCB0byBhdm9pZCBhY2NpZGVudGFsbHkgdW5tb3VudGluZyB0aGUgZW50aXJlIGdhcmZpc2ggYXBwbGljYXRpb24uYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZWxlbWVudFRvUmVuZGVyID0gZ2V0RWxlbWVudFRvUmVuZGVyKG9wdHMsIGFwcEluZm8pO1xuICBjb25zdCBkb21FbGVtZW50ID0gY2hvb3NlRG9tRWxlbWVudEdldHRlcihvcHRzLCBhcHBJbmZvKTtcbiAgY29uc3QgcmVuZGVyUmVzdWx0ID0gY2FsbENyZWF0ZVJvb3Qoe1xuICAgIGVsZW1lbnRUb1JlbmRlcixcbiAgICBkb21FbGVtZW50LFxuICAgIG9wdHMsXG4gIH0pO1xuXG4gIGlmIChvcHRzLmRvbUVsZW1lbnRzKSB7XG4gICAgb3B0cy5kb21FbGVtZW50c1thcHBJbmZvLmFwcE5hbWVdID0gZG9tRWxlbWVudDtcbiAgfVxuICBpZiAob3B0cy5yZW5kZXJSZXN1bHRzKSB7XG4gICAgb3B0cy5yZW5kZXJSZXN1bHRzW2FwcEluZm8uYXBwTmFtZV0gPSByZW5kZXJSZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5tb3VudChvcHRzOiBPcHRpb25zLCBhcHBJbmZvOiBQcm9wc0luZm8pIHtcbiAgaWYgKG9wdHMucmVuZGVyUmVzdWx0cykge1xuICAgIGNvbnN0IHJvb3QgPSBvcHRzLnJlbmRlclJlc3VsdHNbYXBwSW5mby5hcHBOYW1lXTtcbiAgICByb290LnVubW91bnQoKTtcbiAgICBvcHRzLmRvbUVsZW1lbnRzICYmIGRlbGV0ZSBvcHRzLmRvbUVsZW1lbnRzW2FwcEluZm8uYXBwTmFtZV07XG4gICAgZGVsZXRlIG9wdHMucmVuZGVyUmVzdWx0c1thcHBJbmZvLmFwcE5hbWVdO1xuICB9XG59XG5cbi8vIGZ1bmN0aW9uIHVwZGF0ZShvcHRzOiBPcHRpb25zLCBhcHBJbmZvOiBQcm9wc0luZm8pIHtcbi8vICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4vLyAgICAgaWYgKCFvcHRzLnVwZGF0ZVJlc29sdmVzW2FwcEluZm8uYXBwTmFtZV0pIHtcbi8vICAgICAgIG9wdHMudXBkYXRlUmVzb2x2ZXNbYXBwSW5mby5hcHBOYW1lXSA9IFtdO1xuLy8gICAgIH1cblxuLy8gICAgIG9wdHMudXBkYXRlUmVzb2x2ZXNbYXBwSW5mby5hcHBOYW1lXS5wdXNoKHJlc29sdmUpO1xuLy8gICAgIGNvbnN0IGVsZW1lbnRUb1JlbmRlciA9IGdldEVsZW1lbnRUb1JlbmRlcihvcHRzLCBhcHBJbmZvKTtcbi8vICAgICBjb25zdCByZW5kZXJSb290ID0gb3B0cy5yZW5kZXJSZXN1bHRzW2FwcEluZm8uYXBwTmFtZV07XG4vLyAgICAgcmVuZGVyUm9vdC5yZW5kZXIoZWxlbWVudFRvUmVuZGVyKTtcbi8vICAgfSk7XG4vLyB9XG5cbmZ1bmN0aW9uIGF0TGVhc3RSZWFjdDE4KFJlYWN0PzogdHlwZVJlYWN0KSB7XG4gIGlmIChcbiAgICBSZWFjdCAmJlxuICAgIHR5cGVvZiBSZWFjdC52ZXJzaW9uID09PSAnc3RyaW5nJyAmJlxuICAgIFJlYWN0LnZlcnNpb24uaW5kZXhPZignLicpID49IDBcbiAgKSB7XG4gICAgY29uc3QgbWFqb3JWZXJzaW9uU3RyaW5nID0gUmVhY3QudmVyc2lvbi5zcGxpdCgnLicpWzBdO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gTnVtYmVyKG1ham9yVmVyc2lvblN0cmluZykgPj0gMTg7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsQ3JlYXRlUm9vdCh7IG9wdHMsIGVsZW1lbnRUb1JlbmRlciwgZG9tRWxlbWVudCB9KSB7XG4gIGNvbnN0IHJlbmRlclR5cGUgPVxuICAgIHR5cGVvZiBvcHRzLnJlbmRlclR5cGUgPT09ICdmdW5jdGlvbicgPyBvcHRzLnJlbmRlclR5cGUoKSA6IG9wdHMucmVuZGVyVHlwZTtcblxuICBsZXQgcm9vdDtcbiAgaWYgKHJlbmRlclR5cGUgPT09ICdoeWRyYXRlJykge1xuICAgIHJvb3QgPSBvcHRzLmh5ZHJhdGVSb290KGVsZW1lbnRUb1JlbmRlciwgZG9tRWxlbWVudCk7XG4gICAgcm9vdC5yZW5kZXIoZWxlbWVudFRvUmVuZGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBkZWZhdWx0IHRvIHRoaXMgaWYgJ3JlbmRlclR5cGUnIGlzIG51bGwgb3IgZG9lc24ndCBtYXRjaCB0aGUgb3RoZXIgb3B0aW9uc1xuICAgIHJvb3QgPSBvcHRzLmNyZWF0ZVJvb3QoZG9tRWxlbWVudCk7XG4gICAgcm9vdC5yZW5kZXIoZWxlbWVudFRvUmVuZGVyKTtcbiAgfVxuXG4gIHJldHVybiByb290O1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50VG9SZW5kZXIob3B0czogT3B0aW9ucywgYXBwSW5mbzogUHJvcHNJbmZvKSB7XG4gIGNvbnN0IHJvb3RDb21wb25lbnRFbGVtZW50ID0gb3B0cy5SZWFjdD8uY3JlYXRlRWxlbWVudChcbiAgICBvcHRzLnJvb3RDb21wb25lbnQgYXMgYW55LFxuICAgIGFwcEluZm8sXG4gICk7XG5cbiAgbGV0IGVsZW1lbnRUb1JlbmRlciA9IHJvb3RDb21wb25lbnRFbGVtZW50O1xuXG4gIGlmIChvcHRzLmVycm9yQm91bmRhcnkpIHtcbiAgICBlbGVtZW50VG9SZW5kZXIgPSBvcHRzLlJlYWN0Py5jcmVhdGVFbGVtZW50KFxuICAgICAgY3JlYXRlRXJyb3JCb3VuZGFyeShvcHRzKSBhcyBhbnksXG4gICAgICBhcHBJbmZvLFxuICAgICAgZWxlbWVudFRvUmVuZGVyLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnRUb1JlbmRlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JCb3VuZGFyeShvcHRzOiBPcHRpb25zKSB7XG4gIC8vIEF2b2lkaW5nIGJhYmVsIG91dHB1dCBmb3IgY2xhc3Mgc3ludGF4IGFuZCBzdXBlcigpXG4gIC8vIHRvIGF2b2lkIGJsb2F0XG4gIGZ1bmN0aW9uIEdhcmZpc2hTdWJBcHBSZWFjdEVycm9yQm91bmRhcnkodGhpczogYW55LCBhcHBJbmZvOiBQcm9wc0luZm8pIHtcbiAgICAvLyBzdXBlclxuICAgIG9wdHMuUmVhY3Q/LkNvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGNhdWdodEVycm9yOiBudWxsLFxuICAgICAgY2F1Z2h0RXJyb3JJbmZvOiBudWxsLFxuICAgIH07XG5cbiAgICAoXG4gICAgICBHYXJmaXNoU3ViQXBwUmVhY3RFcnJvckJvdW5kYXJ5IGFzIGFueVxuICAgICkuZGlzcGxheU5hbWUgPSBgUmVhY3RCcmlkZ2VSZWFjdEVycm9yQm91bmRhcnkoJHthcHBJbmZvLmFwcE5hbWV9KWA7XG4gIH1cblxuICBHYXJmaXNoU3ViQXBwUmVhY3RFcnJvckJvdW5kYXJ5LnByb3RvdHlwZSA9XG4gICAgb3B0cy5SZWFjdCAmJiBPYmplY3QuY3JlYXRlKG9wdHMuUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cbiAgR2FyZmlzaFN1YkFwcFJlYWN0RXJyb3JCb3VuZGFyeS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmNhdWdodEVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvckJvdW5kYXJ5ID0gb3B0cy5lcnJvckJvdW5kYXJ5O1xuXG4gICAgICByZXR1cm4gZXJyb3JCb3VuZGFyeSAmJiBlcnJvckJvdW5kYXJ5KHRoaXMuc3RhdGUuY2F1Z2h0RXJyb3IsIHRoaXMucHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH07XG5cbiAgR2FyZmlzaFN1YkFwcFJlYWN0RXJyb3JCb3VuZGFyeS5wcm90b3R5cGUuY29tcG9uZW50RGlkQ2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXJyLFxuICAgIGluZm8sXG4gICkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY2F1Z2h0RXJyb3I6IGVycixcbiAgICAgIGNhdWdodEVycm9ySW5mbzogaW5mbyxcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gR2FyZmlzaFN1YkFwcFJlYWN0RXJyb3JCb3VuZGFyeTtcbn1cblxuZnVuY3Rpb24gY2hvb3NlRG9tRWxlbWVudEdldHRlcihvcHRzOiBPcHRpb25zLCBhcHBJbmZvOiBQcm9wc0luZm8pIHtcbiAgY29uc3QgeyBkb206IGNvbnRhaW5lciB9ID0gYXBwSW5mbztcbiAgbGV0IGVsO1xuICBpZiAodHlwZW9mIG9wdHMuZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgZWwgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihvcHRzLmVsKTtcbiAgfSBlbHNlIHtcbiAgICBlbCA9IGNvbnRhaW5lcjtcbiAgfVxuXG4gIGlmICghKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBgcmVhY3QgYnJpZGdlJ3MgZG9tLWVsZW1lbnQtZ2V0dGVyLWhlbHBlcnM6IGVsIGlzIGFuIGludmFsaWQgZG9tIGVsZW1lbnQgZm9yIGFwcGxpY2F0aW9uJyR7XG4gICAgICAgIGFwcEluZm8uYXBwTmFtZVxuICAgICAgfScuIEV4cGVjdGVkIEhUTUxFbGVtZW50LCByZWNlaXZlZCAke3R5cGVvZiBlbH1gLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSUE7QUFDQTtBQUVBO0FBYUEsSUFBTSxjQUFjO0FBQUEsRUFFbEIsZUFBZTtBQUFBLEVBQ2YsbUJBQW1CO0FBQUEsRUFHbkIsWUFBWTtBQUFBLEVBQ1osZUFBZTtBQUFBLEVBQ2YsSUFBSTtBQUFBLEVBQ0osV0FBVztBQUFBLEVBQ1gsa0NBQWtDO0FBQUEsRUFDbEMsYUFBYTtBQUFBLEVBQ2IsZUFBZTtBQUFBLEVBQ2YsZ0JBQWdCO0FBQUE7QUFhWCxxQkFBZ0MsVUFBbUI7QUFDeEQsTUFBSSxPQUFPLGFBQWEsVUFBVTtBQUNoQyxVQUFNLElBQUksTUFBTTtBQUFBO0FBR2xCLFFBQU0sT0FBZ0Isa0NBQ2pCLGNBQ0E7QUFHTCxPQUFLLFFBQVEsS0FBSyxTQUFTO0FBQzNCLE9BQUssYUFBYSxLQUFLLGNBQWM7QUFDckMsT0FBSyxjQUFjLEtBQUssZUFBZTtBQUV2QyxNQUFJLENBQUMsS0FBSyxpQkFBaUIsQ0FBQyxLQUFLLG1CQUFtQjtBQUNsRCxVQUFNLElBQUksTUFDUjtBQUFBO0FBSUosTUFBSSxLQUFLLGlCQUFpQixPQUFPLEtBQUssa0JBQWtCLFlBQVk7QUFDbEUsVUFBTSxNQUNKO0FBQUE7QUFHSixNQUFJLENBQUMsZUFBZSxLQUFLLFFBQVE7QUFDL0IsVUFBTSxNQUNKO0FBQUE7QUFJSixRQUFNLG9CQUFvQjtBQUFBLElBQ3hCLFFBQVEsQ0FBQyxZQUF1QixNQUFNLEtBQUssTUFBTSxNQUFNO0FBQUEsSUFDdkQsU0FBUyxDQUFDLFlBQXVCLFFBQVEsS0FBSyxNQUFNLE1BQU07QUFBQTtBQUs1RCxRQUFNLFdBQVcsZUFBMkIsU0FBUyxPQUFPO0FBQzFELFVBQU0sVUFBVSxL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
